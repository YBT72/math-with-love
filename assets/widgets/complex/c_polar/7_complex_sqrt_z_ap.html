<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMckDpbOc7ymOFAKfCcfdudfA1BErQoRvkDn4CIvQEfRIbMzp" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>

    <!-- Updated Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'David Libre', serif;
            overflow: hidden;
        }
        .math-text {
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        .katex {
            font-size: 1.1em !important;
        }
        /* Style for the toggle switch */
        .toggle-switch {
            display: flex;
            cursor: pointer;
            border: 1px solid #cbd5e1; /* slate-300 */
            border-radius: 0.5rem; /* rounded-lg */
            overflow: hidden;
            width: 100%;
        }
        .toggle-option {
            padding: 0.5rem 0.75rem;
            transition: background-color 0.2s ease-in-out;
            color: #475569; /* slate-600 */
            font-weight: 600; /* font-semibold */
            flex: 1;
            text-align: center;
        }
        .toggle-option.active {
            background-color: #334155; /* slate-700 */
            color: white;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        
        <!-- Grouping container for Title and Canvas -->
        <div class="flex flex-col w-full max-w-4xl">
            <div class="w-full text-center mb-2 flex-shrink-0">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-700">מישור גאוס האינטראקטיבי</h1>
                <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה (w) כדי למצוא את שורשיה</p>
            </div>

            <!-- Rectangular Background Container -->
            <div id="canvas-container" class="w-full bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
                <canvas id="complexPlane"></canvas>
            </div>
        </div>

        <!-- Display Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-4 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600 text-center">
‎                פתרון משוואה ריבועית פשוטה<br>בשדה של מספרים מרוכבים
             </h2>
             
             <!-- Display Mode Toggle Switch -->
            <div class="toggle-switch my-2">
                <span id="polar-btn" class="toggle-option">הצגה קוטבית</span>
                <span id="algebraic-btn" class="toggle-option active">הצגה אלגברית</span>
            </div>

             <div id="valueDisplay" dir="ltr" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-xl font-bold text-green-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <div id="solution1Display" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-xl text-blue-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <div id="solution2Display" class="bg-purple-100 border border-purple-200 p-3 rounded-xl shadow-md text-xl text-purple-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const solution1Display = document.getElementById('solution1Display');
        const solution2Display = document.getElementById('solution2Display');
        const algebraicBtn = document.getElementById('algebraic-btn');
        const polarBtn = document.getElementById('polar-btn');

        // --- Configuration ---
        const pointRadius = 10;
        const mainPointColor = '#16a34a'; // Green-600
        const solution1Color = '#3b82f6'; // Blue-500
        const solution2Color = '#8b5cf6'; // Violet-500
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // --- State ---
        let pointW = { a: -3, b: 4 }; // Represents w = z^2
        let isDragging = false;
        let displayMode = 'algebraic'; // 'algebraic' or 'polar'

        // --- Helper Functions ---
        function formatAlgebraic(p) {
            const epsilon = 0.01;
            const a = p.a;
            const b = p.b;

            if (Math.abs(a) < epsilon && Math.abs(b) < epsilon) return '0';
            if (Math.abs(a) < epsilon) return `${b.toFixed(1)}i`;
            if (Math.abs(b) < epsilon) return `${a.toFixed(1)}`;
            const sign = b >= 0 ? '+' : '-';
            return `${a.toFixed(1)} ${sign} ${Math.abs(b).toFixed(1)}i`;
        };

        function formatPolar(p) {
            const r = Math.sqrt(p.a * p.a + p.b * p.b);
            if (r < 0.01) return '0';
            let theta = Math.atan2(p.b, p.a) * (180 / Math.PI);
            if (theta < 0) theta += 360;
            return `${r.toFixed(1)} cis(${theta.toFixed(1)}°)`;
        }
        
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Math Functions ---
        function calculateSquareRoots(w) {
            const r = Math.sqrt(w.a * w.a + w.b * w.b);
            const theta = Math.atan2(w.b, w.a);
            const root_r = Math.sqrt(r);
            const half_theta = theta / 2;
            const z1 = { a: root_r * Math.cos(half_theta), b: root_r * Math.sin(half_theta) };
            const z2 = { a: -z1.a, b: -z1.b };
            return { z1, z2 };
        }

        // --- Coordinate Conversion Functions ---
        function complexToCanvas(a, b) { return { x: origin.x + a * scale, y: origin.y - b * scale }; }
        function canvasToComplex(x, y) { return { a: (x - origin.x) / scale, b: (origin.y - y) / scale }; }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let x = origin.x - scale; x > 0; x -= scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = origin.y + scale; y < canvas.height; y += scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = origin.y - scale; y > 0; y -= scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            ctx.fillStyle = fontColor; 
            ctx.font = 'bold 16px Tinos'; ctx.fillStyle = labelFontColor; 
            ctx.textAlign = 'right';
            ctx.fillText('Re', canvas.width - 15, origin.y + 15);
            ctx.fillStyle = fontColor; 
            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center';
                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) { ctx.fillText(i.toString(), xPos, origin.y + 15); }
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { ctx.textBaseline = 'middle'; ctx.fillText(i.toString(), origin.x - 12, yPos); }
                }
                ctx.restore();
            }
            ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center'; ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale; ctx.fillText('-6', xPosMinus6, origin.y + 15);
            ctx.textBaseline = 'middle'; let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 12, yPosMinus5);
            ctx.font = 'bold 16px Tinos'; ctx.fillStyle = labelFontColor;
            let yPos5 = origin.y - 5 * scale;
            ctx.textAlign = 'right';
            ctx.fillText('Im', origin.x - 12, yPos5);
            ctx.restore();
        }
        
        function drawPoint(p, radius, color, label) {
            const canvasPos = complexToCanvas(p.a, p.b);
            ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = color; ctx.lineWidth = 2.5; ctx.stroke();
            ctx.beginPath(); ctx.arc(canvasPos.x, canvasPos.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
            drawIntelligentZLabel(canvasPos, p, color, label);
        }

        function drawAngleBetweenRoots(z1) {
            const r = Math.sqrt(z1.a * z1.a + z1.b * z1.b);
            if (r < 0.1) return;

            const arcRadius = r * scale * 0.6;
            const theta1 = Math.atan2(z1.b, z1.a);
            const theta2 = theta1 + Math.PI;

            // Draw semi-transparent segment
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.arc(origin.x, origin.y, arcRadius, -theta1, -theta2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(axisColor, 0.2);
            ctx.fill();
            ctx.restore();

            // Draw dashed arc line
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 4]);
            ctx.arc(origin.x, origin.y, arcRadius, -theta1, -theta2, true);
            ctx.stroke();
            ctx.restore();

            // Draw label
            const labelAngle = -(theta1 + Math.PI / 2);
            const textX = origin.x + (arcRadius + 10) * Math.cos(labelAngle);
            const textY = origin.y + (arcRadius + 10) * Math.sin(labelAngle);
            ctx.save();
            ctx.fillStyle = axisColor;
            ctx.font = 'bold 14px Tinos';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('180°', textX, textY);
            ctx.restore();
        }

        function drawIntelligentZLabel(canvasPos, p, color, label) {
            const offset = 7.5;
            let x = canvasPos.x + offset;
            let y = canvasPos.y - offset;
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Tinos';
            let textAlign = 'left';
            let textBaseline = 'bottom';
            const textWidth = ctx.measureText(label).width;
            const textHeight = 16;
            if (x + textWidth > canvas.width - 10) { x = canvasPos.x - offset; textAlign = 'right'; }
            if (y - textHeight < 10) { y = canvasPos.y + offset; textBaseline = 'top'; }
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            ctx.fillText(label, x, y);
            ctx.restore(); 
        }
        
        function updateDisplay(w, z1, z2) {
            const latexString = "z^2 = w \\implies z_{1,2} = \\pm\\sqrt{w}";
            try {
                if (typeof katex !== 'undefined') {
                    katex.render(latexString, valueDisplay, { throwOnError: false, displayMode: true });
                } else {
                    valueDisplay.innerHTML = `<span dir="ltr"><b>z² = w => z₁,₂ = ±√w</b></span>`;
                }
            } catch (e) {
                console.error("KaTeX rendering failed:", e);
                valueDisplay.innerHTML = `<span dir="ltr"><b>z² = w => z₁,₂ = ±√w</b></span>`;
            }

            const format = displayMode === 'algebraic' ? formatAlgebraic : formatPolar;
            const w_text = `w = ${format(w)}`;
            const z1_text = `z₁ = ${format(z1)}`;
            const z2_text = `z₂ = ${format(z2)}`;

            solution1Display.innerHTML = `<span dir="ltr"><b>${z1_text}</b></span>`;
            solution2Display.innerHTML = `<span dir="ltr"><b>${z2_text}</b></span>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            
            const { z1, z2 } = calculateSquareRoots(pointW);
            
            drawAngleBetweenRoots(z1);

            const format = displayMode === 'algebraic' ? formatAlgebraic : formatPolar;
            drawPoint(pointW, pointRadius, mainPointColor, `w = ${format(pointW)}`);
            drawPoint(z1, pointRadius, solution1Color, 'z₁');
            drawPoint(z2, pointRadius, solution2Color, 'z₂');
            
            updateDisplay(pointW, z1, z2);
        }

        // --- Event Handlers ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top }; }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(pointW.a, pointW.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 5) * (pointRadius + 5)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                pointW = canvasToComplex(pos.x, pos.y);
                drawAll();
            }
        }

        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        function setActiveDisplayButton(btn) {
            [algebraicBtn, polarBtn].forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        algebraicBtn.addEventListener('click', () => {
            displayMode = 'algebraic';
            setActiveDisplayButton(algebraicBtn);
            drawAll();
        });

        polarBtn.addEventListener('click', () => {
            displayMode = 'polar';
            setActiveDisplayButton(polarBtn);
            drawAll();
        });

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;
            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = canvas.width / 13;
                drawAll();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 50);
    </script>
</body>
</html>

