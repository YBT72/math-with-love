<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס האינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'David Libre', serif;
            overflow: hidden; /* Prevent body scrolling */
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas.disabled {
            cursor: not-allowed;
        }
        canvas:active {
            cursor: grabbing;
        }
        .operation-btn.active, .toggle-option.active {
            background-color: #334155; /* slate-700 */
            color: white;
        }
        .operation-btn.active {
             box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        /* Style for the toggle switch */
        .toggle-switch {
            display: flex;
            cursor: pointer;
            border: 1px solid #cbd5e1; /* slate-300 */
            border-radius: 0.5rem; /* rounded-lg */
            overflow: hidden;
            width: 100%;
        }
        .toggle-option {
            padding: 0.5rem 0.75rem;
            transition: background-color 0.2s ease-in-out;
            color: #475569; /* slate-600 */
            font-weight: 600; /* font-semibold */
            flex: 1;
            text-align: center;
        }
        .disabled {
            pointer-events: none;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-6xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8">
        
        <!-- Group for Title and Canvas -->
        <div class="flex flex-col w-full max-w-4xl">
            <!-- Title -->
            <div class="text-center mb-2 flex-shrink-0">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-700">מישור גאוס האינטראקטיבי</h1>
                <p class="text-slate-600 text-sm md:text-base">גרור את הנקודות z<sub>1</sub> ו-z<sub>2</sub> ובחר בפעולה הרצויה</p>
            </div>
            <!-- Canvas Container -->
            <div id="canvas-container" class="w-full bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
                <canvas id="complexPlane"></canvas>
            </div>
        </div>

        <!-- Display & Controls Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-3 mt-2 md:mt-0">
            <h2 class="text-xl font-bold text-slate-700 text-center">פעולות חשבון</h2>
            
            <!-- Display Mode Toggle Switch -->
            <div id="display-switch-container" class="toggle-switch my-2">
                <span id="polar-btn" class="toggle-option">הצגה קוטבית</span>
                <span id="algebraic-btn" class="toggle-option active">הצגה אלגברית</span>
            </div>

            <div id="z1_display" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-xl text-blue-800 w-full text-center"></div>
            <div id="z2_display" class="bg-red-100 border border-red-200 p-3 rounded-xl shadow-md text-xl text-red-800 w-full text-center"></div>
            
            <div id="operation-btn-container" class="flex justify-center items-center gap-2 my-2">
                <button id="add-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-xl w-12 h-12 rounded-full transition-all">+</button>
                <button id="subtract-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-xl w-12 h-12 rounded-full transition-all">-</button>
                <button id="multiply-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-xl w-12 h-12 rounded-full transition-all">×</button>
                <button id="divide-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-xl w-12 h-12 rounded-full transition-all">÷</button>
            </div>

            <div id="result_display" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-xl text-green-800 w-full text-center min-h-[56px] flex items-center justify-center"></div>
            
            <button id="reset-btn" class="w-full bg-yellow-200 hover:bg-yellow-300 text-orange-800 font-bold py-2 px-4 rounded-xl shadow-md mt-2">איפוס</button>
        </div>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const z1Display = document.getElementById('z1_display');
        const z2Display = document.getElementById('z2_display');
        const resultDisplay = document.getElementById('result_display');
        
        // Buttons & Containers
        const addBtn = document.getElementById('add-btn');
        const subtractBtn = document.getElementById('subtract-btn');
        const multiplyBtn = document.getElementById('multiply-btn');
        const divideBtn = document.getElementById('divide-btn');
        const resetBtn = document.getElementById('reset-btn');
        const algebraicBtn = document.getElementById('algebraic-btn');
        const polarBtn = document.getElementById('polar-btn');
        const operationBtnContainer = document.getElementById('operation-btn-container');
        const displaySwitchContainer = document.getElementById('display-switch-container');


        // --- Configuration ---
        const pointRadius = 10;
        const resultPointRadius = 8;
        const colors = {
            z1: '#3b82f6', // blue-500
            z2: '#ef4444', // red-500
            result: '#16a34a', // green-600
            animation: '#f97316' // orange-500
        }
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        const initialPoint1 = { a: 2, b: 3 };
        const initialPoint2 = { a: -1, b: 1 };

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // --- State ---
        let point1 = { ...initialPoint1 }; 
        let point2 = { ...initialPoint2 };
        let resultPoint = null;
        let draggingPoint = null;
        let currentOperation = null;
        let displayMode = 'algebraic';
        let isAnimating = false;

        // --- Utility Functions ---
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Coordinate & Polar Conversion ---
        function complexToCanvas(a, b) { return { x: origin.x + a * scale, y: origin.y - b * scale }; }
        function canvasToComplex(x, y) { return { a: (x - origin.x) / scale, b: (origin.y - y) / scale }; }
        function algebraicToPolar(a, b) {
            const r = Math.sqrt(a * a + b * b);
            let theta = Math.atan2(b, a); // Radians
            return { r, theta };
        }
        function polarToComplex(r, theta) {
            return { a: r * Math.cos(theta), b: r * Math.sin(theta) };
        }

        // --- Calculation ---
        function calculateResult() {
            if (!currentOperation) {
                resultPoint = null;
                drawAll();
                return;
            }
            let res = {};
            switch (currentOperation) {
                case 'add':
                    res.a = point1.a + point2.a;
                    res.b = point1.b + point2.b;
                    break;
                case 'subtract':
                    res.a = point1.a - point2.a;
                    res.b = point1.b - point2.b;
                    break;
                case 'multiply':
                    res.a = (point1.a * point2.a) - (point1.b * point2.b);
                    res.b = (point1.a * point2.b) + (point1.b * point2.a);
                    break;
                case 'divide':
                    const denominator = point2.a * point2.a + point2.b * point2.b;
                    if (Math.abs(denominator) < 1e-9) {
                        res = { a: NaN, b: NaN }; // Division by zero
                    } else {
                        res.a = (point1.a * point2.a + point1.b * point2.b) / denominator;
                        res.b = (point1.b * point2.a - point1.a * point2.b) / denominator;
                    }
                    break;
            }
            resultPoint = res;
            drawAll();
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let x = origin.x - scale; x > 0; x -= scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = origin.y + scale; y < canvas.height; y += scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = origin.y - scale; y > 0; y -= scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            
            const yLabelY = 15; const yLabelXOffset = 12; // Adjusted "Im" label position
            ctx.font = 'bold 16px "David Libre"'; 
            ctx.fillStyle = axisColor; // Changed label color to match axis color
            ctx.textAlign = 'right';
            ctx.fillText('Im', origin.x - yLabelXOffset, yLabelY);
            const labelXPos = canvas.width - 15;
            ctx.fillText('Re', labelXPos, origin.y + 15);
            
            ctx.fillStyle = fontColor; 
            for (let i = -6; i <= 6; i++) {
                if (i === 0) continue;
                ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center'; ctx.font = '14px "David Libre"';
                let xPos = origin.x + i * scale; if (i !== 6) ctx.fillText(i, xPos, origin.y + 15);
                let yPos = origin.y - i * scale; if (i >= -5 && i < 5) ctx.fillText(i, origin.x - 15, yPos);
                ctx.restore();
            }
            ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center'; ctx.font = '14px "David Libre"';
            let yPosMinus5 = origin.y - (-5 * scale); ctx.fillText('-5', origin.x - 15, yPosMinus5);
            ctx.restore();
        }
        
        function drawAngleLabel(angleRad, radius, color, label) {
            const labelAngle = -angleRad / 2;
            const textX = origin.x + (radius + 15) * Math.cos(labelAngle);
            const verticalOffset = -Math.abs((radius + 15) * Math.sin(labelAngle));
            const textY = origin.y + verticalOffset;

            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = color;
            ctx.font = 'italic 16px "David Libre"';
            ctx.textBaseline = 'bottom';
            ctx.textAlign = 'center';
            ctx.fillText(label, textX, textY);
            ctx.restore();
        }
        
        function drawAngleArc(p, color, arcRadius, label, options = {}) {
            const { startAngle = 0, alpha = 1.0, direction = 'ccw' } = options;
            const r_vec = Math.sqrt(p.a * p.a + p.b * p.b);
            if (r_vec * scale < arcRadius || r_vec < 0.1) return;
            
            let angleRad = Math.atan2(p.b, p.a);
            let canvasAngle = -angleRad;
            let canvasStartAngle = -startAngle;
            const isCCW = direction === 'ccw';

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.arc(origin.x, origin.y, arcRadius, canvasStartAngle, canvasAngle, isCCW);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(color, 0.2 * alpha);
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = hexToRgba(color, alpha);
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 4]);
            ctx.arc(origin.x, origin.y, arcRadius, canvasStartAngle, canvasAngle, isCCW);
            ctx.stroke();
            ctx.restore();

            if (label) {
                drawAngleLabel(angleRad, arcRadius, color, label);
            }
        }

        function drawPoint(p, color, name, arcRadius, options = {}) {
            if (!p || isNaN(p.a) || isNaN(p.b)) return;
            const { isAnimating = false } = options;
            const canvasPos = complexToCanvas(p.a, p.b);
            const pointRad = (name === 'z' && !isAnimating) ? resultPointRadius : pointRadius;

            if (displayMode === 'polar' || isAnimating) {
                const label = name === 'z₁' ? 'θ₁' : name === 'z₂' ? 'θ₂' : 'θ';
                drawAngleArc(p, color, arcRadius, label, { direction: 'ccw' });
                ctx.save(); ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(canvasPos.x, canvasPos.y);
                ctx.strokeStyle = color; ctx.lineWidth = 2.5; ctx.stroke(); ctx.restore();
            } else { // algebraic
                ctx.save(); ctx.strokeStyle = color; ctx.setLineDash([3, 3]); ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(canvasPos.x, origin.y); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(origin.x, canvasPos.y); ctx.stroke();
                ctx.restore();
            }

            ctx.beginPath(); ctx.arc(canvasPos.x, canvasPos.y, pointRad, 0, 2 * Math.PI);
            ctx.fillStyle = color; ctx.fill();
            if(pointRad === pointRadius) { ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke(); }
           
            // --- Dynamic Label Positioning Logic ---
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = labelFontColor;
            ctx.font = 'bold 16px "David Libre"';

            const textMetrics = ctx.measureText(name);
            const textWidth = textMetrics.width;
            const textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent || 16;
            const margin = pointRad + 5;
            
            let labelX, labelY;

            // --- Horizontal positioning ---
            let preferredAlign = p.a >= 0 ? 'left' : 'right';
            if (preferredAlign === 'left') {
                labelX = canvasPos.x + margin;
                if (labelX + textWidth > canvas.width) {
                    // If it goes off the right edge, flip to the left
                    ctx.textAlign = 'right';
                    labelX = canvasPos.x - margin;
                } else {
                    ctx.textAlign = 'left';
                }
            } else { // preferredAlign is 'right'
                labelX = canvasPos.x - margin;
                if (labelX - textWidth < 0) {
                    // If it goes off the left edge, flip to the right
                    ctx.textAlign = 'left';
                    labelX = canvasPos.x + margin;
                } else {
                    ctx.textAlign = 'right';
                }
            }

            // --- Vertical positioning ---
            let preferredBaseline = p.b >= 0 ? 'bottom' : 'top';
             ctx.textBaseline = 'middle';
             labelY = canvasPos.y;

            if (canvasPos.y - textHeight < 0) { // Too close to top
                ctx.textBaseline = 'top';
                labelY = canvasPos.y + margin;
            } else if (canvasPos.y + textHeight > canvas.height) { // Too close to bottom
                ctx.textBaseline = 'bottom';
                labelY = canvasPos.y - margin;
            }

            ctx.fillText(name, labelX, labelY);
            ctx.restore();
        }

        function updateDisplay() {
            const opSymbol = {add: '+', subtract: '-', multiply: '×', divide: '÷'}[currentOperation];
            
            function formatPolar(p, name, color) {
                if (!p || isNaN(p.a)) return `<b style="color:${color};">${name}</b> = לא מוגדר`;
                const polar = algebraicToPolar(p.a, p.b);
                let thetaDeg = polar.theta * (180 / Math.PI);
                if (thetaDeg < 0) thetaDeg += 360;
                return `<span style="direction: ltr; display: inline-block;"><b style="color:${color};">${name}</b> = ${polar.r.toFixed(1)} cis(${thetaDeg.toFixed(1)}°)</span>`;
            }
            function formatAlgebraic(p, name, color) {
                 if (!p || isNaN(p.a)) return `<b style="color:${color};">${name}</b> = לא מוגדר`;
                 return `<span style="direction: ltr; display: inline-block;"><b style="color:${color};">${name}</b> = ${p.a.toFixed(1)} ${p.b >= 0 ? '+':'-'} ${Math.abs(p.b).toFixed(1)}i</span>`;
            }

            if (displayMode === 'algebraic') {
                z1Display.innerHTML = formatAlgebraic(point1, 'z₁', colors.z1);
                z2Display.innerHTML = formatAlgebraic(point2, 'z₂', colors.z2);
            } else { // polar
                z1Display.innerHTML = formatPolar(point1, 'z₁', colors.z1);
                z2Display.innerHTML = formatPolar(point2, 'z₂', colors.z2);
            }

            if (!currentOperation || !resultPoint) {
                resultDisplay.innerHTML = '';
            } else if (isNaN(resultPoint.a)) {
                resultDisplay.innerHTML = `לא ניתן לחלק באפס`;
            } else if (displayMode === 'algebraic') {
                resultDisplay.innerHTML = `<span style="direction: ltr; display: inline-block;"><b style="color:${colors.result};">z</b> = z₁ ${opSymbol} z₂ = ${resultPoint.a.toFixed(1)} ${resultPoint.b >= 0 ? '+':'-'} ${Math.abs(resultPoint.b).toFixed(1)}i</span>`;
            } else {
                 resultDisplay.innerHTML = formatPolar(resultPoint, 'z', colors.result);
            }
        }

        function drawAll(options = {}) {
            const { animatingPoint = null, blinkSegments = [] } = options;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            
            drawPoint(point1, colors.z1, 'z₁', 30);
            drawPoint(point2, colors.z2, 'z₂', 45);

            blinkSegments.forEach(seg => {
                drawAngleArc(seg.point, seg.color, seg.radius, null, { startAngle: seg.startAngle, alpha: seg.alpha, direction: seg.direction || 'ccw' });
            });

            if (animatingPoint) {
                 drawPoint(animatingPoint, colors.animation, 'z', 60, { isAnimating: true });
            } else if (!isAnimating) {
                 drawPoint(resultPoint, colors.result, 'z', 60);
            }
            
            updateDisplay();
        }
        
        // --- Animation ---
        async function animateOperation(type) {
            if (isAnimating) return;
            isAnimating = true;
            toggleControls(false);

            const p1_polar = algebraicToPolar(point1.a, point1.b);
            const p2_polar = algebraicToPolar(point2.a, point2.b);

            if (type === 'divide' && p2_polar.r < 1e-9) {
                isAnimating = false;
                toggleControls(true);
                calculateResult();
                return;
            }

            // Stage 1: Blink theta2
            for (let i = 0; i < 4; i++) {
                const isVisible = i % 2 === 0;
                drawAll({ blinkSegments: [{ point: point2, color: colors.z2, radius: 45, alpha: isVisible ? 1.0 : 0.0 }] });
                await new Promise(res => setTimeout(res, 200));
            }

            // Stage 2: Blink the "added" or "subtracted" angle
            const angleChange = type === 'multiply' ? p2_polar.theta : -p2_polar.theta;
            const finalAnglePoint = polarToComplex(1, p1_polar.theta + angleChange);
            for (let i = 0; i < 4; i++) {
                const isVisible = i % 2 === 0;
                drawAll({ blinkSegments: [{ point: finalAnglePoint, color: colors.z2, radius: 60, startAngle: p1_polar.theta, alpha: isVisible ? 1.0 : 0.0, direction: type === 'multiply' ? 'ccw' : 'cw' }] });
                await new Promise(res => setTimeout(res, 200));
            }
            
            await new Promise(res => setTimeout(res, 500)); 

            // Stage 3: Animate rotation and scaling
            let animationAngleChange = angleChange;
            if (animationAngleChange < 0) {
                animationAngleChange += 2 * Math.PI; // Ensure CCW rotation
            }

            const final_r = type === 'multiply' ? p1_polar.r * p2_polar.r : p1_polar.r / p2_polar.r;
            const duration = 6000;
            let startTime = null;

            function animationLoop(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const rotationProgress = Math.min(progress * 2, 1);
                const scalingProgress = Math.max(0, (progress - 0.5) * 2);
                const current_theta = p1_polar.theta + (animationAngleChange * rotationProgress);
                const current_r = p1_polar.r + ((final_r - p1_polar.r) * scalingProgress);
                const animatingPoint = polarToComplex(current_r, current_theta);
                drawAll({ animatingPoint });

                if (progress < 1) {
                    requestAnimationFrame(animationLoop);
                } else {
                    isAnimating = false;
                    toggleControls(true);
                    calculateResult();
                }
            }
            requestAnimationFrame(animationLoop);
        }

        // --- Event Handlers ---
        function resetState() {
            if (isAnimating) return;
            point1 = { ...initialPoint1 };
            point2 = { ...initialPoint2 };
            currentOperation = null;
            resultPoint = null;
            setActiveOperationButton(null);
            drawAll();
        }

        function initializeApp() {
            point1 = { ...initialPoint1 };
            point2 = { ...initialPoint2 };
            currentOperation = null;
            resultPoint = null;
            displayMode = 'algebraic';
            setActiveOperationButton(null);
            setActiveDisplayButton(algebraicBtn);
            resizeCanvas(); // Call resizeCanvas to set initial scale and draw
        }

        function toggleControls(enable) {
            const action = enable ? 'remove' : 'add';
            canvas.classList[action]('disabled');
            operationBtnContainer.classList[action]('disabled');
            displaySwitchContainer.classList[action]('disabled');
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top }; }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            if (isAnimating) return;
            e.preventDefault();
            const pos = getPos(e);
            const p1Pos = complexToCanvas(point1.a, point1.b);
            const p2Pos = complexToCanvas(point2.a, point2.b);
            const d1 = Math.sqrt((pos.x - p1Pos.x)**2 + (pos.y - p1Pos.y)**2);
            const d2 = Math.sqrt((pos.x - p2Pos.x)**2 + (pos.y - p2Pos.y)**2);
            if (d1 < pointRadius + 5) { draggingPoint = point1; } 
            else if (d2 < pointRadius + 5) { draggingPoint = point2; } 
            else { draggingPoint = null; }
            if(draggingPoint) canvas.style.cursor = 'grabbing';
        }

        function handleMove(e) {
            if (isAnimating || !draggingPoint) return;
            e.preventDefault();
            const pos = getPos(e);
            const complexPos = canvasToComplex(pos.x, pos.y);
            draggingPoint.a = complexPos.a;
            draggingPoint.b = complexPos.b;
            if (currentOperation) {
                calculateResult();
            } else {
                drawAll();
            }
        }

        function handleEnd() { draggingPoint = null; canvas.style.cursor = 'grab'; }
        
        function setActiveOperationButton(btn) {
            [addBtn, subtractBtn, multiplyBtn, divideBtn].forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        function setActiveDisplayButton(btn) {
            [algebraicBtn, polarBtn].forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        addBtn.addEventListener('click', () => {
            if (isAnimating) return;
            currentOperation = 'add';
            setActiveOperationButton(addBtn);
            calculateResult();
        });
        subtractBtn.addEventListener('click', () => {
            if (isAnimating) return;
            currentOperation = 'subtract';
            setActiveOperationButton(subtractBtn);
            calculateResult();
        });
        multiplyBtn.addEventListener('click', () => {
            if (isAnimating) return;
            currentOperation = 'multiply';
            setActiveOperationButton(multiplyBtn);
            if (displayMode === 'polar') {
                animateOperation('multiply');
            } else {
                calculateResult();
            }
        });
        divideBtn.addEventListener('click', () => {
            if (isAnimating) return;
            currentOperation = 'divide';
            setActiveOperationButton(divideBtn);
            if (displayMode === 'polar') {
                animateOperation('divide');
            } else {
                calculateResult();
            }
        });
        resetBtn.addEventListener('click', resetState);

        algebraicBtn.addEventListener('click', () => {
            if (isAnimating) return;
            displayMode = 'algebraic';
            setActiveDisplayButton(algebraicBtn);
            drawAll();
        });

        polarBtn.addEventListener('click', () => {
            if (isAnimating) return;
            displayMode = 'polar';
            setActiveDisplayButton(polarBtn);
            drawAll();
        });

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;
            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = canvas.width / 13; 
                drawAll();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        // Initial setup
        initializeApp();
    </script>
</body>
</html>

