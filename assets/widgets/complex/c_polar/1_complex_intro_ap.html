<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General body styling */
        body {
            font-family: 'David Libre', serif;
            overflow: hidden; /* Prevent body scrolling */
        }
        /* Special font for mathematical text */
        .math-text {
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        /* Canvas styling for cursor feedback */
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        /* Styling for the display mode toggle switch */
        .toggle-btn-active {
            background-color: #475569; /* slate-600 */
            color: white;
        }
        .toggle-btn-inactive {
            background-color: #e2e8f0; /* slate-200 */
            color: #475569; /* slate-600 */
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <!-- Main container for the layout -->
    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        
        <!-- START: Wrapper for Canvas and its Title -->
        <div class="w-full max-w-4xl flex flex-col items-center">
             <div class="text-center mb-2 flex-shrink-0">
                <!-- MODIFICATION (A): Changed h1 text color to text-slate-700 (asphalt gray) -->
                <h1 class="text-2xl md:text-3xl font-bold text-slate-700">מישור גאוס האינטראקטיבי</h1>
                <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה כדי לשנות את המספר המרוכב</p>
            </div>
            <!-- Container for the canvas to maintain aspect ratio -->
            <div id="canvas-container" class="w-full bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
                <canvas id="complexPlane"></canvas>
            </div>
        </div>
        <!-- END: Wrapper for Canvas and its Title -->


        <!-- START: Display & Controls Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-4 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600">מבוא למספרים מרוכבים</h2>
             <!-- START: Display Mode Toggle -->
            <div class="w-full flex justify-center my-2">
                <!-- MODIFICATION (B, C): Container is now full-width (w-full) to match the boxes below. Border is now 1px (border instead of border-2). -->
                <div class="flex border border-slate-300 rounded-lg overflow-hidden w-full">
                    <button id="polarBtn" class="toggle-btn-inactive px-4 py-1 text-sm font-bold transition-colors w-1/2">הצגה קוטבית</button>
                    <button id="algebraicBtn" class="toggle-btn-active px-4 py-1 text-sm font-bold transition-colors w-1/2">הצגה אלגברית</button>
                </div>
            </div>
            <!-- END: Display Mode Toggle -->
             <!-- Main value display -->
             <div id="valueDisplay" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-2xl font-bold w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <!-- Real part display -->
             <div id="realPartDisplay" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-base text-blue-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <!-- Imaginary part display -->
             <div id="imagPartDisplay" class="bg-red-100 border-red-200 p-3 rounded-xl shadow-md text-base text-red-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
        </div>
        <!-- END: Display & Controls Container -->
    </div>


    <script>
        // --- Setup ---
        // Get references to DOM elements
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const realPartDisplay = document.getElementById('realPartDisplay');
        const imagPartDisplay = document.getElementById('imagPartDisplay');
        const polarBtn = document.getElementById('polarBtn');
        const algebraicBtn = document.getElementById('algebraicBtn');
        let displayMode = 'algebraic'; // Default display mode

        // --- Configuration & Constants ---
        const pointRadius = 10;
        const pointColor = '#16a34a'; // Green-600
        const realColor = '#3b82f6'; // Blue-500
        const imagColor = '#ef4444'; // Red-500
        const polarRadiusColor = '#f97316'; // Orange-500
        const polarAngleColor = '#6366f1'; // Indigo-500
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#475569'; 

        // --- State Variables ---
        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // Draggable point state
        let point = { a: 1, b: 2 }; // Initial complex number z = 1 + 2i
        let isDragging = false;

        // --- Coordinate Conversion Functions ---
        /**
         * Converts complex number coordinates (a, b) to canvas pixel coordinates (x, y).
         * @param {number} a - The real part.
         * @param {number} b - The imaginary part.
         * @returns {{x: number, y: number}} The corresponding canvas coordinates.
         */
        function complexToCanvas(a, b) {
            return {
                x: origin.x + a * scale,
                y: origin.y - b * scale // Y-axis is inverted in canvas
            };
        }

        /**
         * Converts canvas pixel coordinates (x, y) to complex number coordinates (a, b).
         * @param {number} x - The canvas x-coordinate.
         * @param {number} y - The canvas y-coordinate.
         * @returns {{a: number, b: number}} The corresponding complex number.
         */
        function canvasToComplex(x, y) {
            return {
                a: (x - origin.x) / scale,
                b: (origin.y - y) / scale // Y-axis is inverted in canvas
            };
        }

        // --- Drawing Functions ---
        /**
         * Draws the background grid on the canvas.
         */
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            // Draw vertical lines
            for (let x = origin.x + scale; x < canvas.width; x += scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let x = origin.x - scale; x > 0; x -= scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = origin.y + scale; y < canvas.height; y += scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            for (let y = origin.y - scale; y > 0; y -= scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }

        /**
         * Draws the real (Re) and imaginary (Im) axes, including labels and numbers.
         */
        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            // Real axis (X) with arrowhead
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();

            // Imaginary axis (Y) with arrowhead
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            
            // Draw axis labels and numbers
            ctx.fillStyle = fontColor;
            ctx.font = '14px Tinos';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // MODIFICATION (D): Save context and set direction to LTR for drawing numbers
            ctx.save();
            ctx.direction = 'ltr';

            // Draw numbers on real axis
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) {
                   ctx.fillText(i, xPos, origin.y + 15);
                }
            }
            // Draw numbers on imaginary axis
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                let yPos = origin.y - i * scale;
                if (yPos > 20 && yPos < canvas.height - 20) { 
                   ctx.fillText(i.toString(), origin.x - 15, yPos);
                }
            }
            
            // MODIFICATION (D): Restore context after drawing numbers
            ctx.restore();
            
            // Draw axis labels ('Re', 'Im')
            ctx.font = 'bold 16px Tinos';
            ctx.fillText('Re', canvas.width - 25, origin.y + 20);
            ctx.fillText('Im', origin.x - 25, 15);
        }
        
        /**
         * Draws the main point representing the complex number and its projections onto the axes.
         */
        function drawPointAndProjections() {
            const canvasPos = complexToCanvas(point.a, point.b);

            // In algebraic mode, draw dashed lines for projections
            if (displayMode === 'algebraic') {
                ctx.save();
                ctx.setLineDash([4, 4]); // Dashed line style
                
                // Projection to real axis
                ctx.strokeStyle = realColor;
                ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(canvasPos.x, origin.y); ctx.stroke();

                // Projection to imaginary axis
                ctx.strokeStyle = imagColor;
                ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(origin.x, canvasPos.y); ctx.stroke();
                ctx.restore(); 
                
                // Highlight the real and imaginary components on the axes
                const highlightRadius = 5;
                ctx.fillStyle = realColor;
                const realPos = complexToCanvas(point.a, 0);
                ctx.beginPath(); ctx.arc(realPos.x, realPos.y, highlightRadius, 0, 2 * Math.PI); ctx.fill();

                ctx.fillStyle = imagColor;
                const imagPos = complexToCanvas(0, point.b);
                ctx.beginPath(); ctx.arc(imagPos.x, imagPos.y, highlightRadius, 0, 2 * Math.PI); ctx.fill();
            }

            // Draw the main point
            ctx.beginPath(); ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = pointColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        /**
         * Draws the vector from the origin to the point in polar mode.
         */
        function drawRadiusVector() {
            if (displayMode !== 'polar') return;
            const canvasPos = complexToCanvas(point.a, point.b);
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = pointColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();
        }

        /**
         * Helper function to draw an arrowhead at a specific point and angle.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         * @param {number} x - The x-coordinate of the arrowhead tip.
         * @param {number} y - The y-coordinate of the arrowhead tip.
         * @param {number} angle - The angle of the arrowhead.
         * @param {string} color - The color of the arrowhead.
         */
        function drawArrowhead(ctx, x, y, angle, color) {
            const headlen = 8;
            ctx.save();
            ctx.fillStyle = color;
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-headlen, headlen / 2.5);
            ctx.lineTo(-headlen, -headlen / 2.5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        /**
         * Draws the angle arc (argument θ) in polar mode.
         */
        function drawAngleArc() {
            if (displayMode !== 'polar') return;

            const angleRad = Math.atan2(point.b, point.a);
            const arcRadius = scale * 0.7;
            const canvasAngle = -angleRad; // Invert for canvas coordinates

            ctx.save();
            ctx.strokeStyle = polarAngleColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Arc is drawn clockwise in canvas, so we use a negative angle
            ctx.arc(origin.x, origin.y, arcRadius, 0, canvasAngle, angleRad > 0);
            ctx.stroke();
            
            // Draw arrowhead at the end of the arc
            const endX = origin.x + arcRadius * Math.cos(canvasAngle);
            const endY = origin.y + arcRadius * Math.sin(canvasAngle);
            const tangentAngle = canvasAngle + (angleRad < 0 ? Math.PI / 2 : -Math.PI / 2);
            drawArrowhead(ctx, endX, endY, tangentAngle, polarAngleColor);

            // Draw the 'θ' label
            ctx.fillStyle = polarAngleColor;
            ctx.font = 'bold 14px Tinos';
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const labelAngle = canvasAngle / 2; // Position label in the middle of the arc
            const labelRadius = arcRadius * 0.6;
            const textX = origin.x + labelRadius * Math.cos(labelAngle);
            const textY = origin.y + labelRadius * Math.sin(labelAngle);
            ctx.fillText('θ', textX, textY);
            ctx.restore();
        }

        /**
         * Updates the HTML display elements with the current complex number's values.
         */
        function updateDisplay() {
            const radius = Math.hypot(point.a, point.b);
            const angleRad = Math.atan2(point.b, point.a);
            let angleDeg = angleRad * 180 / Math.PI;

            // Determine if the number is real, imaginary, or complex
            let statusText, statusColor;
            const epsilon = 1e-2;
            if (Math.abs(point.b) < epsilon) {
                statusText = 'מספר ממשי טהור';
                statusColor = realColor;
            } else if (Math.abs(point.a) < epsilon) {
                statusText = 'מספר מדומה טהור';
                statusColor = imagColor;
            } else { 
                statusText = 'מספר מרוכב';
                statusColor = pointColor;
            }

            // Update displays based on the current mode (algebraic or polar)
            if (displayMode === 'algebraic') {
                const imagSign = point.b >= 0 ? '+' : '-';
                const valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                
                valueDisplay.innerHTML = `${valueHTML}<br><span class="text-sm font-normal" style="color: ${statusColor}; font-family: 'David Libre', serif;">(${statusText})</span>`;
                realPartDisplay.innerHTML = `<b style="direction: ltr;">Re</b>(z) = <b style="color:#3b82f6;">${point.a.toFixed(1)}</b><br><span class="text-sm font-normal" style="font-family: 'David Libre', serif;">(החלק הממשי)</span>`;
                imagPartDisplay.innerHTML = `<b style="direction: ltr;">Im</b>(z) = <b style="color:#ef4444;">${point.b.toFixed(1)}</b><br><span class="text-sm font-normal" style="font-family: 'David Libre', serif;">(החלק המדומה)</span>`;
            } else { // Polar mode
                const polarHTML = `<span style="direction: ltr;"><span style="color: ${pointColor};">z = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color: ${pointColor};"> cis(</span><span style="color:${polarAngleColor};">${angleDeg.toFixed(0)}°</span><span style="color: ${pointColor};">)</span></span>`;

                valueDisplay.innerHTML = `${polarHTML}<br><span class="text-sm font-normal" style="color: ${statusColor}; font-family: 'David Libre', serif;">(${statusText})</span>`;
                
                // MODIFICATION: Changed text to mathematical notation (r = ..., θ = ...)
                realPartDisplay.innerHTML = `<b style="direction: ltr;">r = <span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span></b><br><span class="text-sm font-normal" style="font-family: 'David Libre', serif;">(המרחק מהראשית)</span>`;
                imagPartDisplay.innerHTML = `<b style="direction: ltr;">θ = <span style="color:${polarAngleColor};">${angleDeg.toFixed(0)}°</span></b><br><span class="text-sm font-normal" style="font-family: 'David Libre', serif;">(הארגומנט)</span>`;
            }
        }

        /**
         * Main drawing function. Clears the canvas and redraws everything.
         */
        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawRadiusVector();
            drawPointAndProjections();
            drawAngleArc();
            updateDisplay();
        }
        
        // --- Event Handlers ---
        /**
         * Gets the mouse or touch position relative to the canvas.
         * @param {MouseEvent|TouchEvent} e - The event object.
         * @returns {{x: number, y: number}} The position.
         */
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        }
        
        /**
         * Handles the start of a drag operation (mousedown or touchstart).
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            // Check if the click is within the point's radius
            if (dx * dx + dy * dy < (pointRadius + 5) * (pointRadius + 5)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        /**
         * Handles the drag movement (mousemove or touchmove).
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                point.a = complexPos.a;
                point.b = complexPos.b;
                drawAll(); // Redraw everything on move
            }
        }

        /**
         * Handles the end of a drag operation (mouseup, mouseleave, touchend, touchcancel).
         */
        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        // Add all necessary event listeners for mouse and touch
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        /**
         * Sets the display mode and updates the UI and canvas.
         * @param {'algebraic'|'polar'} mode - The new display mode.
         */
        function setDisplayMode(mode) {
            displayMode = mode;
            // Update button styles
            if (mode === 'polar') {
                polarBtn.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                algebraicBtn.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
            } else {
                algebraicBtn.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                polarBtn.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
            }
            drawAll(); // Redraw with the new mode
        }

        // Add listeners for the display mode toggle buttons
        polarBtn.addEventListener('click', () => setDisplayMode('polar'));
        algebraicBtn.addEventListener('click', () => setDisplayMode('algebraic'));

        /**
         * Resizes the canvas to fit its container, recalculating origin and scale.
         */
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            if (!parent) return;
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                // Adjust scale based on width to maintain a consistent view
                scale = canvas.width / 13; 
                drawAll();
            }
        }

        // Add resize listener to the window
        window.addEventListener('resize', resizeCanvas);
        
        // --- Initial Load ---
        // A short delay to ensure layout is stable before the initial canvas render
        setTimeout(resizeCanvas, 50);

    </script>
</body>
</html>

