<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'David Libre', serif;
            overflow: hidden; 
        }
        .math-text {
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        .interactive-box {
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
        }
        .interactive-box:hover {
            transform: scale(1.05);
        }
        .action-btn {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        /* Style for the toggle switch */
        .toggle-switch {
            display: flex;
            cursor: pointer;
            border: 1px solid #cbd5e1; /* slate-300 */
            border-radius: 0.75rem; /* rounded-xl */
            overflow: hidden;
            font-size: 0.875rem; /* text-sm */
        }
        .toggle-option {
            padding: 0.5rem 0.75rem;
            transition: background-color 0.2s ease-in-out;
            color: #475569; /* slate-600 */
        }
        .toggle-option.active {
            background-color: #334155; /* slate-700 */
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        
        <!-- Right side container for Canvas and its header -->
        <div class="flex flex-col items-center w-full max-w-4xl">
            <!-- Header for the canvas -->
            <div class="w-full text-center mb-2 flex-shrink-0">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-700">מישור גאוס האינטראקטיבי</h1>
                <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה או לחץ על הפעולות</p>
            </div>
            <!-- Canvas Container -->
            <div id="canvas-container" class="w-full bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
                <canvas id="complexPlane"></canvas>
            </div>
        </div>

        <!-- Left side container for controls -->
        <div class="w-full max-w-xs flex flex-col justify-center space-y-4 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600 text-center">משמעות גיאומטרית של כפל ב- i</h2>
             
             <!-- Toggle Switch for Display Mode -->
             <div id="displayModeSwitch" class="toggle-switch w-full mx-auto">
                <span id="modePolar" class="toggle-option flex-1 text-center">הצגה קוטבית</span>
                <span id="modeAlgebraic" class="toggle-option flex-1 text-center active">הצגה אלגברית</span>
             </div>

             <div id="valueDisplay" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-2xl font-bold w-full text-center math-text min-h-[90px] flex items-center justify-center">
                <!-- Content for z will be generated by JS -->
            </div>
             <!-- Container for the two side-by-side boxes -->
             <div class="flex gap-2 w-full">
                <div id="multiplyByI" class="interactive-box flex-1 text-center bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-2xl text-blue-800 font-bold">
                    <span class="math-text" dir="ltr">z &times; i</span>
                </div>
                <div id="multiplyByNegI" class="interactive-box flex-1 text-center bg-red-100 border border-red-200 p-3 rounded-xl shadow-md text-2xl text-red-800 font-bold">
                    <span class="math-text" dir="ltr">z &times; (-i)</span>
                </div>
            </div>
             <!-- Reset Button -->
            <button id="resetBtn" class="action-btn w-full bg-yellow-200 hover:bg-yellow-300 text-orange-800 font-bold py-2 px-4 rounded-xl shadow-md">איפוס</button>
        </div>
    </div>


    <script>
        // --- Setup ---
        // Get references to DOM elements
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const multiplyByI = document.getElementById('multiplyByI');
        const multiplyByNegI = document.getElementById('multiplyByNegI');
        const resetBtn = document.getElementById('resetBtn');
        const modeAlgebraic = document.getElementById('modeAlgebraic');
        const modePolar = document.getElementById('modePolar');

        // --- Configuration ---
        // Define colors and sizes for drawing
        const pointRadius = 10;
        const pointColor = '#16a34a'; // Green-600
        const resultPointColor = '#3b82f6'; // Blue-500
        const negResultPointColor = '#ef4444'; // Red-500 (Changed for better contrast)
        const realColor = '#3b82f6';
        const imagColor = '#ef4444'; 
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 

        // Canvas properties
        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // --- State ---
        // Initialize state variables
        let point = { a: 1, b: 0 }; // The main complex number z = a + bi
        let history = { pos: [], neg: [] }; // History of multiplications
        let isDragging = false;
        let isAnimating = false;
        let displayMode = 'algebraic'; // Can be 'algebraic' or 'polar'

        // --- Utility Functions ---
        // Converts a hex color string to an rgba string
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Coordinate Conversion ---
        // Convert complex number coordinates to canvas coordinates
        function complexToCanvas(a, b) { return { x: origin.x + a * scale, y: origin.y - b * scale }; }
        // Convert canvas coordinates to complex number coordinates
        function canvasToComplex(x, y) { return { a: (x - origin.x) / scale, b: (origin.y - y) / scale }; }

        // --- Drawing Functions ---
        // Draws the background grid
        function drawGrid() {
            ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let x = origin.x - scale; x > 0; x -= scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = origin.y + scale; y < canvas.height; y += scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = origin.y - scale; y > 0; y -= scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }

        // Draws the Real and Imaginary axes
        function drawAxes() {
            ctx.strokeStyle = axisColor; ctx.lineWidth = 2;
            // Real axis (x-axis)
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();
            // Imaginary axis (y-axis)
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2);  ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            
            // Draw labels and numbers
            ctx.fillStyle = fontColor; ctx.font = '14px "David Libre"'; 
            ctx.textAlign = 'right'; 
            ctx.font = 'bold 16px Tinos'; ctx.fillStyle = fontColor;
            ctx.fillText('Re', canvas.width - 15, origin.y + 15);
            ctx.fillStyle = fontColor;
            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center';
                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) { ctx.fillText(i.toString(), xPos, origin.y + 15); }
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { ctx.textBaseline = 'middle'; ctx.fillText(i.toString(), origin.x - 12, yPos); }
                }
                ctx.restore();
            }
            ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center'; ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale; ctx.fillText('-6', xPosMinus6, origin.y + 15);
            ctx.textBaseline = 'middle'; let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 12, yPosMinus5); ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = fontColor;
            let yPos5 = origin.y - 5 * scale;
            ctx.fillText('Im', origin.x - 17, yPos5);
            ctx.restore();
        }

        // Draws the dashed circle representing the modulus (r)
        function drawDynamicCircle() {
            const radius = Math.sqrt(point.a * point.a + point.b * point.b) * scale;
            if (radius < 1) return; 
            ctx.save(); ctx.beginPath(); ctx.strokeStyle = '#9ca3af'; // gray-400
            ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
            ctx.arc(origin.x, origin.y, radius, 0, 2 * Math.PI); ctx.stroke(); ctx.restore();
        }
        
        // Draws a single complex point (vector and circle)
        function drawComplexPoint(p, color, index, alpha = 1.0) {
            if (!p) return;
            const rgbaColor = hexToRgba(color, alpha);
            const canvasPos = complexToCanvas(p.a, p.b);
            const epsilon = 0.01;
            const isOverlapping = Math.abs(p.a - point.a) < epsilon && Math.abs(p.b - point.b) < epsilon && index !== 0;

            // Draw the vector from origin to the point
            ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = rgbaColor; ctx.lineWidth = 2.5; ctx.stroke();
            
            // Draw the circle at the point's location
            ctx.beginPath(); ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = hexToRgba('#FFFFFF', alpha); ctx.lineWidth = 3; 
            
            if (isOverlapping) {
                ctx.strokeStyle = rgbaColor; ctx.lineWidth = 2; ctx.stroke();
            } else {
                ctx.fillStyle = rgbaColor; ctx.fill(); ctx.stroke();
            }
            
            drawSubscriptLabel(canvasPos, color, index, alpha, isOverlapping);
        }

        // Draws a right-angle marker between two vectors
        function drawRightAngleMarker(start, end, color, alpha) {
            if (!start || !end) return;
            const size = 20; 
            const len1 = Math.sqrt(start.a ** 2 + start.b ** 2);
            if (len1 === 0) return;

            const u1 = { a: start.a / len1, b: start.b / len1 };
            const u2 = { a: end.a / len1, b: end.b / len1 };
            
            const p1_marker = { a: u1.a * size / scale, b: u1.b * size / scale };
            const p2_marker = { a: u2.a * size / scale, b: u2.b * size / scale };
            const p3_marker = { a: p1_marker.a + p2_marker.a, b: p1_marker.b + p2_marker.b };

            const c_p1 = complexToCanvas(p1_marker.a, p1_marker.b);
            const c_p2 = complexToCanvas(p2_marker.a, p2_marker.b);
            const c_p3 = complexToCanvas(p3_marker.a, p3_marker.b);

            ctx.save();
            ctx.strokeStyle = hexToRgba(axisColor, alpha);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(c_p1.x, c_p1.y);
            ctx.lineTo(c_p3.x, c_p3.y);
            ctx.lineTo(c_p2.x, c_p2.y);
            ctx.stroke();
            ctx.restore();
        }
        
        // Draws the z_n label next to a point
        function drawSubscriptLabel(canvasPos, color, index, alpha, isOverlapping = false) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = hexToRgba(color, alpha); 
            ctx.textBaseline = 'bottom';

            ctx.font = 'bold 18px Tinos';
            const baseText = 'z';
            const baseWidth = ctx.measureText(baseText).width;

            ctx.font = 'bold 14px Tinos';
            const subText = index.toString();

            const totalWidth = baseWidth + ctx.measureText(subText).width;
            const margin = 15;
            
            let xOffset = canvasPos.x + margin;
            if (isOverlapping || (xOffset + totalWidth > canvas.width - margin)) {
                xOffset = canvasPos.x - margin - totalWidth;
            }

            ctx.font = 'bold 18px Tinos';
            ctx.fillText(baseText, xOffset, canvasPos.y);
            ctx.font = 'bold 14px Tinos';
            ctx.fillText(subText, xOffset + baseWidth, canvasPos.y + 4);

            ctx.restore();
        }

        // Draws a text label that can contain subscript parts
        function drawLabelWithSubscripts(x, y, color, alpha, parts) {
            ctx.save();
            ctx.fillStyle = hexToRgba(color, alpha);
            ctx.textBaseline = 'alphabetic'; 
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';

            // Calculate total width for manual centering if needed, but textAlign handles it
            let totalWidth = 0;
            parts.forEach(part => {
                ctx.font = part.type === 'sub' ? '11px Tinos' : '14px Tinos';
                totalWidth += ctx.measureText(part.text).width;
            });

            // Draw parts sequentially
            let currentX = x - totalWidth / 2;
             ctx.textAlign = 'left';

            parts.forEach(part => {
                const isSub = part.type === 'sub';
                ctx.font = isSub ? '11px Tinos' : '14px Tinos';
                const yOffset = isSub ? 4 : 0; // Offset for subscript
                ctx.fillText(part.text, currentX, y + yOffset);
                currentX += ctx.measureText(part.text).width;
            });

            ctx.restore();
        }

        // Draws a semi-transparent sector for the angle and its label
        function drawAngleSector(startRad, endRad, color, labelParts, sectorRadius, isClockwise, alpha = 1.0) {
            // Draw the semi-transparent sector
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            // Use negative angles because canvas y-axis is inverted
            // The last parameter is `anticlockwise`, so we pass the opposite of isClockwise
            ctx.arc(origin.x, origin.y, sectorRadius, -startRad, -endRad, isClockwise);
            ctx.closePath();
            // Apply a base transparency and the fade-out alpha
            ctx.fillStyle = hexToRgba(color, 0.25 * alpha);
            ctx.fill();

            // Draw the text label in the middle of the sector
            let angleDiff = endRad - startRad;
            
            // Normalize the angle difference based on direction
            if (isClockwise) {
                if (angleDiff > 0) angleDiff -= 2 * Math.PI;
            } else {
                if (angleDiff < 0) angleDiff += 2 * Math.PI;
            }

            const midAngleRad = startRad + angleDiff / 2;
            
            const textRadius = sectorRadius * 0.6; // Place label at 60% of the radius
            const textX = origin.x + textRadius * Math.cos(midAngleRad);
            const textY = origin.y - textRadius * Math.sin(midAngleRad); // y is inverted

            // Use a solid color for the text for readability, but still allow fade-out
            drawLabelWithSubscripts(textX, textY, color, alpha, labelParts);
            ctx.restore();
        }
        
        // Updates the display panel with the current point's value
        function updateDisplay() {
            let valueHTML;
            let statusText, statusColor;
            const epsilon = 0.001;
            const r = Math.sqrt(point.a * point.a + point.b * point.b);

            // Determine the type of number (real, imaginary, etc.)
            if (r < epsilon) {
                statusText = 'האפס המרוכב';
                statusColor = fontColor;
            } else if (Math.abs(point.b) < epsilon) {
                statusText = 'מספר ממשי טהור';
                statusColor = realColor;
            } else if (Math.abs(point.a) < epsilon) {
                statusText = 'מספר מדומה טהור';
                statusColor = imagColor;
            } else {
                statusText = 'מספר מרוכב';
                statusColor = pointColor;
            }

            // Build the display string based on the current mode (algebraic/polar)
            if (displayMode === 'algebraic') {
                if (r < epsilon) {
                     valueHTML = `<span style="color: ${pointColor};">z = 0</span>`;
                } else if (Math.abs(point.b) < epsilon) {
                    valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
                } else if (Math.abs(point.a) < epsilon) {
                    valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${imagColor};">${point.b.toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                } else {
                    const imagSign = point.b >= 0 ? '+' : '-';
                    valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                }
            } else { // polar mode
                if (r < epsilon) {
                    valueHTML = `<span style="color: ${pointColor};">z = 0</span>`;
                } else {
                    let thetaRad = Math.atan2(point.b, point.a);
                    let thetaDeg = thetaRad * (180 / Math.PI);
                    if (thetaDeg < 0) {
                        thetaDeg += 360;
                    }
                    valueHTML = `<span style="color: ${pointColor};">z = </span>
                                 <span style="color: ${realColor};">${r.toFixed(2)}</span>
                                 <span style="color: ${pointColor};"> cis(</span>
                                 <span style="color: ${imagColor};">${thetaDeg.toFixed(1)}&deg;</span>
                                 <span style="color: ${pointColor};">)</span>`;
                }
            }

            const statusHTML = `<br><span class="text-sm font-normal" style="color: ${statusColor}; font-family: 'David Libre', serif;">(${statusText})</span>`;
            valueDisplay.innerHTML = `<div>${valueHTML}${statusHTML}</div>`;
        }

        // Main drawing function, called on every frame
        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            
            // Draw angle sectors if in polar mode
            if (displayMode === 'polar') {
                const baseRadius = Math.sqrt(point.a * point.a + point.b * point.b) * scale;

                // Draw sectors for the history first so they are in the background
                history.pos.forEach((item, i) => {
                    const alpha = i === history.pos.length - 1 ? 1.0 : 0.5;
                    const labelParts = [{ type: 'normal', text: '+90°' }];
                    const startRad = Math.atan2(item.start.b, item.start.a);
                    const endRad = Math.atan2(item.point.b, item.point.a);
                    // Draw from previous angle to new angle, CCW (isClockwise = true)
                    drawAngleSector(startRad, endRad, resultPointColor, labelParts, baseRadius, true, alpha);
                });
                history.neg.forEach((item, i) => {
                    const alpha = i === history.neg.length - 1 ? 1.0 : 0.5;
                    const labelParts = [{ type: 'normal', text: '-90°' }];
                    const startRad = Math.atan2(item.start.b, item.start.a);
                    const endRad = Math.atan2(item.point.b, item.point.a);
                    // Draw from previous angle to new angle, CW (isClockwise = false)
                    drawAngleSector(startRad, endRad, negResultPointColor, labelParts, baseRadius, false, alpha);
                });

                // Draw the main green sector on top
                let baseAngleRad = Math.atan2(point.b, point.a);
                let baseAngleDeg = baseAngleRad * (180 / Math.PI);
                if (baseAngleDeg < 0) baseAngleDeg += 360;
                const baseLabelParts = [
                    { type: 'normal', text: 'θ' },
                    { type: 'sub', text: '0' },
                    { type: 'normal', text: ` = ${baseAngleDeg.toFixed(1)}°` }
                ];
                // Draw from angle 0 to the point's angle, always CCW
                drawAngleSector(0, baseAngleRad, pointColor, baseLabelParts, baseRadius, true, 1.0);
            }
            
            drawDynamicCircle();

            // Draw all points
            drawComplexPoint(point, pointColor, 0);

            history.pos.forEach((item, i) => {
                const isLast = i === history.pos.length - 1;
                const alpha = isLast ? 1.0 : Math.max(0.1, 1.0 - (history.pos.length - 1 - i) * 0.25);
                drawRightAngleMarker(item.start, item.point, resultPointColor, alpha);
                drawComplexPoint(item.point, resultPointColor, i + 1, alpha);
            });
            history.neg.forEach((item, i) => {
                const isLast = i === history.neg.length - 1;
                const alpha = isLast ? 1.0 : Math.max(0.1, 1.0 - (history.neg.length - 1 - i) * 0.25);
                drawRightAngleMarker(item.start, item.point, negResultPointColor, alpha);
                drawComplexPoint(item.point, negResultPointColor, -(i + 1), alpha);
            });
            updateDisplay();
        }

        // --- Animation ---
        // Animates the rotation of a point
        function animateRotation(start, end, angle, color, index, historyArray) {
            isAnimating = true;
            let startTime = null;
            const radius = Math.sqrt(start.a ** 2 + start.b ** 2);
            const startAngle = Math.atan2(start.b, start.a);
            const endAngle = startAngle + angle;

            function animationStep(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / 500, 1);
                const currentAngle = startAngle + (endAngle - startAngle) * progress;
                const animatingPoint = { a: radius * Math.cos(currentAngle), b: radius * Math.sin(currentAngle) };

                // Redraw the scene with the animating point
                drawAll(); // Draw the static background first
                
                // Then draw the animating point on top
                drawComplexPoint(animatingPoint, color, index);
                
                if (progress < 1) {
                    requestAnimationFrame(animationStep);
                } else {
                    isAnimating = false;
                    historyArray.push({start: start, point: end});
                    drawAll(); 
                }
            }
            requestAnimationFrame(animationStep);
        }

        // Recalculates the history points based on a new base point
        function updateHistoryFromBase(basePoint) {
            let lastPos = basePoint;
            history.pos.forEach(item => {
                item.start = { ...lastPos };
                item.point = { a: -lastPos.b, b: lastPos.a }; // z * i
                lastPos = item.point;
            });
            
            let lastNeg = basePoint;
            history.neg.forEach(item => {
                item.start = { ...lastNeg };
                item.point = { a: lastNeg.b, b: -lastNeg.a }; // z * (-i)
                lastNeg = item.point;
            });
        }


        // --- Event Handlers ---
        // Gets the mouse/touch position relative to the canvas
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        // Handles the start of a drag operation
        function handleStart(e) {
            if (isAnimating) return;
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x; const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 10) * (pointRadius + 10)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        // Handles the move event during a drag
        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                point = canvasToComplex(pos.x, pos.y);
                updateHistoryFromBase(point); 
                drawAll();
            }
        }

        // Handles the end of a drag operation
        function handleEnd() { isDragging = false; canvas.style.cursor = 'grab'; }

        // Event listener for switching to algebraic mode
        modeAlgebraic.addEventListener('click', () => {
            displayMode = 'algebraic';
            modeAlgebraic.classList.add('active');
            modePolar.classList.remove('active');
            drawAll();
        });

        // Event listener for switching to polar mode
        modePolar.addEventListener('click', () => {
            displayMode = 'polar';
            modePolar.classList.add('active');
            modeAlgebraic.classList.remove('active');
            drawAll();
        });

        // Event listener for the "z * i" button
        multiplyByI.addEventListener('click', () => {
            if(isAnimating) return;
            const startPoint = history.pos.length > 0 ? history.pos[history.pos.length - 1].point : point;
            const endPoint = { a: -startPoint.b, b: startPoint.a };
            const nextIndex = history.pos.length + 1;
            animateRotation(startPoint, endPoint, Math.PI / 2, resultPointColor, nextIndex, history.pos);
        });
        
        // Event listener for the "z * (-i)" button
        multiplyByNegI.addEventListener('click', () => {
            if(isAnimating) return;
            const startPoint = history.neg.length > 0 ? history.neg[history.neg.length - 1].point : point;
            const endPoint = { a: startPoint.b, b: -startPoint.a };
            const nextIndex = -(history.neg.length + 1);
            animateRotation(startPoint, endPoint, -Math.PI / 2, negResultPointColor, nextIndex, history.neg);
        });

        // Event listener for the reset button
        resetBtn.addEventListener('click', () => {
            if (isAnimating) return;
            point = { a: 1, b: 0 };
            history = { pos: [], neg: [] };
            drawAll();
        });

        // Mouse and Touch event listeners for the canvas
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        // Handles canvas resizing
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth; const parentHeight = parent.clientHeight;
            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth; canvas.height = parentHeight;
                origin.x = canvas.width / 2; origin.y = canvas.height / 2;
                scale = canvas.width / 13; 
                drawAll();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        // Initial resize after a short delay to ensure layout is stable
        setTimeout(resizeCanvas, 50);
    </script>
</body>
</html>

