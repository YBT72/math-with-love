<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Updated Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            /* Updated font for Hebrew text */
            font-family: 'David Libre', serif;
            overflow: auto; /* Allow scrolling for more content */
        }
        .math-text {
            /* Updated font for Mathematical text */
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        /* Style for the toggle switch */
        .toggle-btn-active {
            background-color: #475569; /* slate-600 */
            color: white;
        }
        .toggle-btn-inactive {
            background-color: #e2e8f0; /* slate-200 */
            color: #475569; /* slate-600 */
        }

        /* START: Operation Button Styles */
        .op-button { transition: background-color 0.2s, color 0.2s; }
        
        /* Add Button */
        .op-add-active { background-color: #f97316; color: white; border-color: #fff7ed; }
        .op-add-inactive { background-color: #fff7ed; color: #f97316; border-color: #f97316; }

        /* Subtract Button */
        .op-subtract-active { background-color: #0ea5e9; color: white; border-color: #f0f9ff; }
        .op-subtract-inactive { background-color: #f0f9ff; color: #0ea5e9; border-color: #0ea5e9; }

        /* Multiply Button */
        .op-multiply-active { background-color: #f43f5e; color: white; border-color: #fff1f2; }
        .op-multiply-inactive { background-color: #fff1f2; color: #f43f5e; border-color: #f43f5e; }

        /* Divide Button */
        .op-divide-active { background-color: #14b8a6; color: white; border-color: #f0fdfa; }
        .op-divide-inactive { background-color: #f0fdfa; color: #14b8a6; border-color: #14b8a6; }
        /* END: Operation Button Styles */
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        
        <!-- START: Wrapper for Canvas and its Title -->
        <div class="w-full max-w-4xl flex flex-col items-center">
            <div class="text-center mb-2">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-700">מישור גאוס האינטראקטיבי</h1>
                <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה כדי לשנות את המספר המרוכב</p>
            </div>
            <!-- Rectangular Background Container -->
            <div id="canvas-container" class="w-full bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
                <canvas id="complexPlane"></canvas>
            </div>
        </div>
        <!-- END: Wrapper for Canvas and its Title -->

        <!-- Display Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-2 mt-2 md:mt-0">
             <h2 class="text-center font-bold text-slate-600 leading-tight mb-2">
                <span class="text-xl">ערך מוחלט וצמוד למספר מרוכב:</span><br>
                <span class="text-lg">משמעות גיאומטרית</span>
             </h2>

            <!-- START: Display Mode Toggle -->
            <div class="w-full flex justify-center my-2">
                <div class="flex border border-slate-300 rounded-lg overflow-hidden w-full">
                    <button id="polarBtn" class="flex-1 toggle-btn-inactive px-4 py-1 text-sm font-bold transition-colors">הצגה קוטבית</button>
                    <button id="algebraicBtn" class="flex-1 toggle-btn-active px-4 py-1 text-sm font-bold transition-colors">הצגה אלגברית</button>
                </div>
            </div>
            <!-- END: Display Mode Toggle -->

            <!-- NEW: Parallel columns container -->
            <div class="flex flex-row-reverse gap-2 w-full">
                <!-- Column for z -->
                <div class="flex flex-col gap-2 w-1/2">
                    <div id="valueDisplay" class="bg-green-100 border border-green-200 p-2 rounded-xl shadow-md text-lg font-bold w-full text-center math-text flex items-center justify-center" style="height: 52px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="box1_z_label" class="p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center" style="height: 44px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="box2_z_label" class="p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center" style="height: 44px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="box3_z_label" class="p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center" style="height: 44px;">
                        <!-- Content generated by JS -->
                    </div>
                </div>

                <!-- Column for z-bar -->
                <div class="flex flex-col gap-2 w-1/2">
                    <div id="conjugateValueDisplay" class="bg-purple-100 border border-purple-200 p-2 rounded-xl shadow-md text-lg font-bold w-full text-center math-text flex items-center justify-center" style="height: 52px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="box1_z_bar_label" class="p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center" style="height: 44px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="box2_z_bar_label" class="p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center" style="height: 44px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="box3_z_bar_label" class="p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center" style="height: 44px;">
                        <!-- Content generated by JS -->
                    </div>
                </div>
            </div>
            <!-- START: Updated Buttons Container -->
            <div id="buttons-container" class="w-full flex flex-col gap-2 mt-3">
                 <h3 class="text-center font-bold text-slate-600 leading-tight">פעולות</h3>
                 <div class="flex gap-1.5 w-full">
                    <button id="addButton" class="op-button flex-1 font-bold py-1 px-2 rounded-md shadow-md math-text text-base border">z+z&#x0304;</button>
                    <button id="subtractButton" class="op-button flex-1 font-bold py-1 px-2 rounded-md shadow-md math-text text-base border">z-z&#x0304;</button>
                    <button id="multiplyButton" class="op-button flex-1 font-bold py-1 px-2 rounded-md shadow-md math-text text-base border">z&times;z&#x0304;</button>
                    <button id="divideButton" class="op-button flex-1 font-bold py-1 px-2 rounded-md shadow-md math-text text-base border">z/z&#x0304;</button>
                 </div>
                 <div class="flex gap-1.5 w-full mt-1">
                    <button id="resetButton" class="w-1/3 bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors border border-slate-500">איפוס</button>
                    <div id="resultDisplayBox" class="flex-grow bg-slate-200 border border-slate-300 rounded-md shadow-inner text-center flex items-center justify-center math-text text-base p-2">
                        <!-- Result will be displayed here -->
                    </div>
                 </div>
            </div>
            <!-- END: Updated Buttons Container -->
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const box1_z_label = document.getElementById('box1_z_label');
        const box2_z_label = document.getElementById('box2_z_label');
        const box3_z_label = document.getElementById('box3_z_label');
        const conjugateValueDisplay = document.getElementById('conjugateValueDisplay');
        const box1_z_bar_label = document.getElementById('box1_z_bar_label');
        const box2_z_bar_label = document.getElementById('box2_z_bar_label');
        const box3_z_bar_label = document.getElementById('box3_z_bar_label');
        const resultDisplayBox = document.getElementById('resultDisplayBox');
        
        const addButton = document.getElementById('addButton');
        const subtractButton = document.getElementById('subtractButton');
        const resetButton = document.getElementById('resetButton');
        const multiplyButton = document.getElementById('multiplyButton');
        const divideButton = document.getElementById('divideButton');
        const opButtons = document.querySelectorAll('.op-button');

        const polarBtn = document.getElementById('polarBtn');
        const algebraicBtn = document.getElementById('algebraicBtn');
        let displayMode = 'algebraic'; // 'algebraic' or 'polar'
        
        let currentOperation = null; // Can be 'add', 'subtract', 'multiply', 'divide', or null
        
        // --- Configuration ---
        const pointRadius = 10;
        const pointColor = '#16a34a'; // Green-600
        const conjugateColor = '#8b5cf6'; // Violet-500
        
        // Algebraic Colors
        const realColor = '#3b82f6'; // Blue-500
        const imagColor = '#ef4444'; // Red-500
        const modulusColor = '#ca8a04'; // Amber-600

        // Polar Colors
        const polarRadiusColor = '#f97316'; // Orange-500
        const polarAngleColor = '#6366f1'; // Indigo-500

        // Result Colors
        const resultAddColor = '#f97316'; // Orange-500
        const resultSubtractColor = '#0ea5e9'; // Sky-500
        const resultMultiplyColor = '#f43f5e'; // Rose-500
        const resultDivideColor = '#14b8a6'; // Teal-500
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        let point = { a: 1, b: 2 }; 
        let isDragging = false;

        // --- Utility Functions ---
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Coordinate Conversion Functions ---
        function complexToCanvas(a, b) {
            return {
                x: origin.x + a * scale,
                y: origin.y - b * scale
            };
        }

        function canvasToComplex(x, y) {
            return {
                a: (x - origin.x) / scale,
                b: (origin.y - y) / scale
            };
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            for (let x = origin.x + scale; x < canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let x = origin.x - scale; x > 0; x -= scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = origin.y + scale; y < canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            for (let y = origin.y - scale; y > 0; y -= scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(canvas.width, origin.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 12, origin.y - 7);
            ctx.lineTo(canvas.width - 2, origin.y);
            ctx.lineTo(canvas.width - 12, origin.y + 7);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(origin.x, canvas.height);
            ctx.lineTo(origin.x, 2); 
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(origin.x - 7, 12);
            ctx.lineTo(origin.x, 2);
            ctx.lineTo(origin.x + 7, 12);
            ctx.stroke();
            
            ctx.fillStyle = fontColor;
            
            const labelXPos = canvas.width - 15;

            ctx.font = 'bold 16px Tinos';
            ctx.textAlign = 'right';
            ctx.fillText('Re', labelXPos, origin.y + 15);

            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save();
                ctx.direction = 'ltr';
                ctx.textAlign = 'center';

                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) {
                   ctx.fillText(i, xPos, origin.y + 15);
                }
                
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { 
                       ctx.textBaseline = 'middle';
                       ctx.fillText(i.toString(), origin.x - 15, yPos);
                    }
                }
                ctx.restore();
            }
            ctx.save();
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';
            ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale;
            ctx.fillText('-6', xPosMinus6, origin.y + 15);
            
            ctx.textBaseline = 'middle';
            let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 15, yPosMinus5);
            
            ctx.font = 'bold 16px Tinos';
            let yPos5 = origin.y - 5 * scale;
            ctx.fillText('Im', origin.x - 15, yPos5);

            ctx.restore();
        }

        function drawRadiusVectorsAndLabels() {
            const radius = Math.sqrt(point.a * point.a + point.b * point.b);
            const canvasPos = complexToCanvas(point.a, point.b);
            const conjugateCanvasPos = complexToCanvas(point.a, -point.b);
            
            // Vector colors match point colors
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = pointColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(conjugateCanvasPos.x, conjugateCanvasPos.y);
            ctx.strokeStyle = conjugateColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            // Label colors match their respective value types
            const label = displayMode === 'algebraic' ? '|z|' : 'r';
            const labelColor = displayMode === 'polar' ? polarRadiusColor : modulusColor;
            drawRadiusLabel(point.a, point.b, radius, label, labelColor);
            drawRadiusLabel(point.a, -point.b, radius, label, labelColor);
        }

        function drawRadiusLabel(a, b, radius, label, color) {
            if (radius * scale < 30) return;

            ctx.save();
            
            const midX = origin.x + (a * scale) / 2;
            const midY = origin.y - (b * scale) / 2;
            ctx.translate(midX, midY);

            let angle = Math.atan2(-b, a);

            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                angle += Math.PI;
            }
            
            ctx.rotate(angle);

            ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            ctx.direction = 'ltr';
            const textToDraw = `${label} = ${radius.toFixed(1)}`;
            
            const textWidth = ctx.measureText(textToDraw).width;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillRect(-textWidth/2 - 4, -18, textWidth + 8, 20);

            ctx.fillStyle = color;
            ctx.fillText(textToDraw, 0, 0);
            
            ctx.restore();
        }

        function drawPointAndProjections() {
            if (displayMode !== 'algebraic') return;

            const canvasPos = complexToCanvas(point.a, point.b);

            ctx.save();
            ctx.setLineDash([4, 4]); 
            
            ctx.strokeStyle = realColor;
            ctx.lineWidth = 1; 
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(canvasPos.x, origin.y);
            ctx.stroke();

            ctx.strokeStyle = imagColor;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(origin.x, canvasPos.y);
            ctx.stroke();
            ctx.restore(); 
            
            const highlightRadius = 5;

            ctx.fillStyle = realColor;
            const realPos = complexToCanvas(point.a, 0);
            ctx.beginPath();
            ctx.arc(realPos.x, realPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = imagColor;
            const imagPos = complexToCanvas(0, point.b);
            ctx.beginPath();
            ctx.arc(imagPos.x, imagPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawConjugatePointProjections() {
             if (displayMode !== 'algebraic') return;

            const conjugateB = -point.b;
            const canvasPos = complexToCanvas(point.a, conjugateB);

            ctx.save();
            ctx.setLineDash([4, 4]);

            ctx.strokeStyle = realColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(canvasPos.x, origin.y);
            ctx.stroke();

            ctx.strokeStyle = imagColor;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(origin.x, canvasPos.y);
            ctx.stroke();
            ctx.restore();

            const highlightRadius = 5;

            ctx.fillStyle = imagColor;
            const imagPos = complexToCanvas(0, conjugateB);
            ctx.beginPath();
            ctx.arc(imagPos.x, imagPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawMainPoints() {
            const canvasPos = complexToCanvas(point.a, point.b);
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = pointColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            drawIntelligentZLabel(canvasPos);

            const conjugateCanvasPos = complexToCanvas(point.a, -point.b);
            ctx.beginPath();
            ctx.arc(conjugateCanvasPos.x, conjugateCanvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = conjugateColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            drawIntelligentConjugateLabel(conjugateCanvasPos);
        }
        
        function drawIntelligentConjugateLabel(canvasPos) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.font = 'bold 16px Tinos';

            const textHeight = 16;
            const margin = 5;
            
            let fullText, parts;
            const radius = Math.sqrt(point.a * point.a + point.b * point.b);
            const angleRad = Math.atan2(-point.b, point.a);
            const angleDeg = angleRad * 180 / Math.PI;

            if (displayMode === 'algebraic') {
                const zText = 'z\u0304 = ';
                const realText = point.a.toFixed(1);
                const imagText = Math.abs(point.b).toFixed(1);
                const signText = point.b >= 0 ? ' - ' : ' + ';
                const iText = 'i';
                fullText = zText + realText + signText + imagText + iText;
                parts = [
                    { text: zText, color: conjugateColor },
                    { text: realText, color: realColor },
                    { text: signText, color: conjugateColor },
                    { text: imagText, color: imagColor },
                    { text: iText, color: conjugateColor }
                ];
            } else { // polar
                const zText = 'z\u0304 = ';
                const rText = radius.toFixed(1);
                const cisText = ' cis(';
                const angleText = `${angleDeg.toFixed(1)}°`;
                const endText = ')';
                fullText = zText + rText + cisText + angleText + endText;
                parts = [
                   { text: zText, color: conjugateColor },
                   { text: rText, color: polarRadiusColor },
                   { text: cisText, color: conjugateColor },
                   { text: angleText, color: polarAngleColor },
                   { text: endText, color: conjugateColor },
                ];
            }

            const textWidth = ctx.measureText(fullText).width;
            
            let textBaseline = 'top';
            let yOffset = canvasPos.y + pointRadius + margin;
            if (yOffset + textHeight > canvas.height - 5) {
                textBaseline = 'bottom';
                yOffset = canvasPos.y - (pointRadius / 2);
            }

            let xOffset = canvasPos.x + pointRadius + margin;
            if (xOffset + textWidth > canvas.width - 15) {
                xOffset = canvasPos.x - pointRadius - margin - textWidth;
            }
            
            ctx.textBaseline = textBaseline;
            ctx.textAlign = 'left';
            
            let currentX = xOffset;
            parts.forEach(part => {
                ctx.fillStyle = part.color;
                ctx.fillText(part.text, currentX, yOffset);
                currentX += ctx.measureText(part.text).width;
            });
            
            ctx.restore();
        }

        function drawIntelligentZLabel(canvasPos) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.font = 'bold 16px Tinos';

            const textHeight = 16;
            const margin = 5;

            let fullText, parts;
            const radius = Math.sqrt(point.a * point.a + point.b * point.b);
            const angleRad = Math.atan2(point.b, point.a);
            const angleDeg = angleRad * 180 / Math.PI;

            if (displayMode === 'algebraic') {
                const zText = 'z = ';
                const realText = point.a.toFixed(1);
                const imagText = Math.abs(point.b).toFixed(1);
                const signText = point.b >= 0 ? ' + ' : ' - ';
                const iText = 'i';
                fullText = zText + realText + signText + imagText + iText;
                parts = [
                    { text: zText, color: pointColor },
                    { text: realText, color: realColor },
                    { text: signText, color: pointColor },
                    { text: imagText, color: imagColor },
                    { text: iText, color: pointColor }
                ];
            } else { // polar
                const zText = 'z = ';
                const rText = radius.toFixed(1);
                const cisText = ' cis(';
                const angleText = `${angleDeg.toFixed(1)}°`;
                const endText = ')';
                fullText = zText + rText + cisText + angleText + endText;
                parts = [
                   { text: zText, color: pointColor },
                   { text: rText, color: polarRadiusColor },
                   { text: cisText, color: pointColor },
                   { text: angleText, color: polarAngleColor },
                   { text: endText, color: pointColor },
                ];
            }

            const textWidth = ctx.measureText(fullText).width;

            let textBaseline = 'bottom';
            let yOffset = canvasPos.y - (pointRadius / 2);
            if (yOffset - textHeight < 5) {
                textBaseline = 'top';
                yOffset = canvasPos.y + pointRadius + margin;
            }

            let xOffset = canvasPos.x + pointRadius + margin;
            if (xOffset + textWidth > canvas.width - 15) {
                xOffset = canvasPos.x - pointRadius - margin - textWidth;
            }

            ctx.textBaseline = textBaseline;
            ctx.textAlign = 'left';

            let currentX = xOffset;
            parts.forEach(part => {
                ctx.fillStyle = part.color;
                ctx.fillText(part.text, currentX, yOffset);
                currentX += ctx.measureText(part.text).width;
            });
            
            ctx.restore(); 
        }

        function drawResult() {
            if (!currentOperation) {
                resultDisplayBox.innerHTML = '';
                return;
            }

            let resultPoint, resultColor, labelText, valueText;
            const epsilon = 0.05;

            if (currentOperation === 'add') {
                resultPoint = { a: 2 * point.a, b: 0 };
                resultColor = resultAddColor;
                labelText = 'z + z\u0304 = ';
            } else if (currentOperation === 'subtract') {
                resultPoint = { a: 0, b: 2 * point.b };
                resultColor = resultSubtractColor;
                labelText = 'z - z\u0304 = ';
            } 
            else if (currentOperation === 'multiply') {
                const modSq = point.a * point.a + point.b * point.b;
                resultPoint = { a: modSq, b: 0 };
                resultColor = resultMultiplyColor;
                labelText = 'z \u00D7 z\u0304 = ';
            } else if (currentOperation === 'divide') {
                const modSq = point.a * point.a + point.b * point.b;
                resultColor = resultDivideColor;
                labelText = 'z / z\u0304 = ';
                if (modSq < epsilon) {
                    resultPoint = null;
                } else {
                    const angleZ_rad = Math.atan2(point.b, point.a);
                    const angleResult_rad = 2 * angleZ_rad;
                    resultPoint = {
                        a: Math.cos(angleResult_rad),
                        b: Math.sin(angleResult_rad)
                    };
                }
            }

            if (!resultPoint) {
                valueText = 'Undefined';
                resultDisplayBox.innerHTML = `<b style="direction: ltr;">${labelText}<span style="color:${resultColor};">${valueText}</span></b>`;
                const canvasPos = complexToCanvas(0,0);
                drawIntelligentResultLabel(canvasPos, labelText, valueText, resultColor);
                return;
            }
            
            if (displayMode === 'polar') {
                const r = Math.sqrt(resultPoint.a * resultPoint.a + resultPoint.b * resultPoint.b);
                const thetaRad = Math.atan2(resultPoint.b, resultPoint.a);
                const thetaDeg = thetaRad * 180 / Math.PI;
                valueText = `${r.toFixed(1)} cis(${thetaDeg.toFixed(1)}°)`;
            } else {
                const realPart = resultPoint.a.toFixed(1);
                const imagPart = resultPoint.b.toFixed(1);
                
                if (Math.abs(resultPoint.b) < epsilon) {
                    valueText = `${realPart}`;
                } else if (Math.abs(resultPoint.a) < epsilon) {
                    valueText = `${imagPart}i`;
                } else {
                    const sign = resultPoint.b >= 0 ? ' + ' : ' - ';
                    valueText = `${realPart} ${sign} ${Math.abs(imagPart)}i`;
                }
            }
            
            resultDisplayBox.innerHTML = `<b style="direction: ltr;">${labelText}<span style="color:${resultColor};">${valueText}</span></b>`;

            const canvasPos = complexToCanvas(resultPoint.a, resultPoint.b);
            
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = resultColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            drawIntelligentResultLabel(canvasPos, labelText, valueText, resultColor);
        }

        function drawIntelligentResultLabel(canvasPos, label, value, color) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.font = 'bold 16px Tinos';

            const textHeight = 16;
            const margin = 5;
            const fullText = label + value;
            const textWidth = ctx.measureText(fullText).width;

            let textBaseline = 'bottom';
            let yOffset = canvasPos.y - pointRadius - margin;
            if (yOffset - textHeight < 5) {
                textBaseline = 'top';
                yOffset = canvasPos.y + pointRadius + margin;
            }

            let textAlign = 'center';
            let xOffset = canvasPos.x;
            
            if (canvasPos.x + textWidth / 2 > canvas.width - 15) {
                textAlign = 'right';
                xOffset = canvasPos.x - pointRadius - margin;
            } else if (canvasPos.x - textWidth / 2 < 15) {
                textAlign = 'left';
                xOffset = canvasPos.x + pointRadius + margin;
            }

            ctx.textBaseline = textBaseline;
            ctx.textAlign = textAlign;

            ctx.fillStyle = color;
            ctx.fillText(fullText, xOffset, yOffset);
            
            ctx.restore();
        }
        
        // NEW function to draw a sector instead of an arc
        function drawAngleSector(angleRad, arcRadius, color, label, anticlockwise) {
            if (displayMode !== 'polar') return;

            const canvasAngle = -angleRad;

            ctx.save();
            // Draw the semi-transparent sector
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.arc(origin.x, origin.y, arcRadius, 0, canvasAngle, anticlockwise);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(color, 0.2);
            ctx.fill();

            // Draw the label inside the sector
            ctx.fillStyle = color;
            ctx.font = 'bold 14px Tinos';
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const labelAngle = canvasAngle / 2;
            const labelRadius = arcRadius * 0.6; // Position inside the sector
            const textX = origin.x + labelRadius * Math.cos(labelAngle);
            const textY = origin.y + labelRadius * Math.sin(labelAngle);
            ctx.fillText(label, textX, textY);
            ctx.restore();
        }

        function updateDisplay() {
            const radius = Math.sqrt(point.a * point.a + point.b * point.b);
            const angleRad = Math.atan2(point.b, point.a);
            const angleDeg = angleRad * 180 / Math.PI;
            const conjugateAngleDeg = -angleDeg;
            const epsilon = 0.05;

            const baseClass = "p-2 rounded-xl shadow-md text-base w-full text-center math-text flex items-center justify-center";

            if (displayMode === 'algebraic') {
                valueDisplay.style.fontSize = '';
                conjugateValueDisplay.style.fontSize = '';

                let valueHTML, conjugateValueHTML;
                if (Math.abs(point.b) < epsilon) {
                    valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
                    conjugateValueHTML = `<span style="color: ${conjugateColor};">z\u0304 = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
                } else if (Math.abs(point.a) < epsilon) {
                    valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${imagColor};">${point.b.toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                    conjugateValueHTML = `<span style="color: ${conjugateColor};">z\u0304 = </span><span style="color: ${imagColor};">${(-point.b).toFixed(1)}</span><span style="color: ${conjugateColor};">i</span>`;
                } else {
                    const imagSign = point.b >= 0 ? '+' : '-';
                    const conjugateImagSign = point.b >= 0 ? '-' : '+';
                    valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                    conjugateValueHTML = `<span style="color: ${conjugateColor};">z\u0304 = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${conjugateColor};">${conjugateImagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${conjugateColor};">i</span>`;
                }
                valueDisplay.innerHTML = `<span style="direction: ltr;">${valueHTML}</span>`;
                conjugateValueDisplay.innerHTML = `<span style="direction: ltr;">${conjugateValueHTML}</span>`;
                
                box1_z_label.className = `bg-blue-100 border-blue-200 text-blue-800 ${baseClass}`;
                box2_z_label.className = `bg-red-100 border-red-200 text-red-800 ${baseClass}`;
                box3_z_label.className = `bg-yellow-100 border-yellow-200 text-yellow-800 ${baseClass}`;
                box1_z_bar_label.className = `bg-blue-100 border-blue-200 text-blue-800 ${baseClass}`;
                box2_z_bar_label.className = `bg-red-100 border-red-200 text-red-800 ${baseClass}`;
                box3_z_bar_label.className = `bg-yellow-100 border-yellow-200 text-yellow-800 ${baseClass}`;

                box1_z_label.innerHTML = `<b style="direction: ltr;">Re(z) = <b style="color:${realColor};">${point.a.toFixed(1)}</b></b>`;
                box2_z_label.innerHTML = `<b style="direction: ltr;">Im(z) = <b style="color:${imagColor};">${point.b.toFixed(1)}</b></b>`;
                box3_z_label.innerHTML = `<b style="direction: ltr;">|z| = <b style="color:${modulusColor};">${radius.toFixed(1)}</b></b>`;
                box1_z_bar_label.innerHTML = `<b style="direction: ltr;">Re(z\u0304) = <b style="color:${realColor};">${point.a.toFixed(1)}</b></b>`;
                box2_z_bar_label.innerHTML = `<b style="direction: ltr;">Im(z\u0304) = <b style="color:${imagColor};">${(-point.b).toFixed(1)}</b></b>`;
                box3_z_bar_label.innerHTML = `<b style="direction: ltr;">|z\u0304| = <b style="color:${modulusColor};">${radius.toFixed(1)}</b></b>`;
            } else { // polar
                valueDisplay.style.fontSize = '16px';
                conjugateValueDisplay.style.fontSize = '16px';

                valueDisplay.innerHTML = `<span style="direction: ltr;"><span style="color: ${pointColor};">z = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color: ${pointColor};"> cis(</span><span style="color:${polarAngleColor};">${angleDeg.toFixed(1)}°</span><span style="color: ${pointColor};">)</span></span>`;
                conjugateValueDisplay.innerHTML = `<span style="direction: ltr;"><span style="color: ${conjugateColor};">z\u0304 = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color: ${conjugateColor};"> cis(</span><span style="color:${polarAngleColor};">${conjugateAngleDeg.toFixed(1)}°</span><span style="color: ${conjugateColor};">)</span></span>`;
                
                box1_z_label.className = `bg-blue-100 border-blue-200 text-blue-800 ${baseClass}`;
                box2_z_label.className = `bg-red-100 border-red-200 text-red-800 ${baseClass}`;
                box3_z_label.className = `bg-orange-100 border-orange-200 text-orange-800 ${baseClass}`;
                box1_z_bar_label.className = `bg-blue-100 border-blue-200 text-blue-800 ${baseClass}`;
                box2_z_bar_label.className = `bg-red-100 border-red-200 text-red-800 ${baseClass}`;
                box3_z_bar_label.className = `bg-orange-100 border-orange-200 text-orange-800 ${baseClass}`;

                box1_z_label.innerHTML = `<b style="direction: ltr; font-size: 13px;"><span style="color:${realColor};">Re(z) = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color:${realColor};">cos(</span><span style="color:${polarAngleColor};">${angleDeg.toFixed(1)}°</span><span style="color:${realColor};">)</span></b>`;
                box2_z_label.innerHTML = `<b style="direction: ltr; font-size: 13px;"><span style="color:${imagColor};">Im(z) = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color:${imagColor};">sin(</span><span style="color:${polarAngleColor};">${angleDeg.toFixed(1)}°</span><span style="color:${imagColor};">)</span></b>`;
                box3_z_label.innerHTML = `<b style="direction: ltr;">r = <b style="color:${polarRadiusColor};">${radius.toFixed(1)}</b></b>`;
                
                box1_z_bar_label.innerHTML = `<b style="direction: ltr; font-size: 13px;"><span style="color:${realColor};">Re(z\u0304) = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color:${realColor};">cos(</span><span style="color:${polarAngleColor};">${conjugateAngleDeg.toFixed(1)}°</span><span style="color:${realColor};">)</span></b>`;
                box2_z_bar_label.innerHTML = `<b style="direction: ltr; font-size: 13px;"><span style="color:${imagColor};">Im(z\u0304) = </span><span style="color:${polarRadiusColor};">${radius.toFixed(1)}</span><span style="color:${imagColor};">sin(</span><span style="color:${polarAngleColor};">${conjugateAngleDeg.toFixed(1)}°</span><span style="color:${imagColor};">)</span></b>`;
                box3_z_bar_label.innerHTML = `<b style="direction: ltr;">r = <b style="color:${polarRadiusColor};">${radius.toFixed(1)}</b></b>`;
            }
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            
            if (currentOperation === 'divide') {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(origin.x, origin.y, 1 * scale, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            drawRadiusVectorsAndLabels(); 
            drawPointAndProjections();
            drawConjugatePointProjections();
            
            if (displayMode === 'polar') {
                const angleRad = Math.atan2(point.b, point.a);
                drawAngleSector(angleRad, scale * 0.7, polarAngleColor, 'θ', true);

                const conjugateAngleRad = Math.atan2(-point.b, point.a);
                drawAngleSector(conjugateAngleRad, scale * 0.5, polarAngleColor, '-θ', false);
            }

            drawMainPoints();
            updateDisplay();
            drawResult();
        }

        // --- Event Handlers ---

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 5) * (pointRadius + 5)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                point.a = complexPos.a;
                point.b = complexPos.b;
                drawAll();
            }
        }

        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        const opButtonConfig = {
            'addButton': { operation: 'add', active: 'op-add-active', inactive: 'op-add-inactive' },
            'subtractButton': { operation: 'subtract', active: 'op-subtract-active', inactive: 'op-subtract-inactive' },
            'multiplyButton': { operation: 'multiply', active: 'op-multiply-active', inactive: 'op-multiply-inactive' },
            'divideButton': { operation: 'divide', active: 'op-divide-active', inactive: 'op-divide-inactive' }
        };

        const resultBoxConfig = {
            'add': 'op-add-inactive',
            'subtract': 'op-subtract-inactive',
            'multiply': 'op-multiply-inactive',
            'divide': 'op-divide-inactive'
        };

        function updateButtonStyles(activeButtonId) {
            opButtons.forEach(button => {
                const config = opButtonConfig[button.id];
                if (button.id === activeButtonId) {
                    button.classList.remove(config.inactive);
                    button.classList.add(config.active);
                } else {
                    button.classList.remove(config.active);
                    button.classList.add(config.inactive);
                }
            });
        }

        function updateResultBoxStyle(operation) {
            const baseClass = "flex-grow rounded-md shadow-inner text-center flex items-center justify-center math-text text-base p-2 border";
            if (operation && resultBoxConfig[operation]) {
                const colorClass = opButtonConfig[Object.keys(opButtonConfig).find(key => opButtonConfig[key].operation === operation)].inactive;
                resultDisplayBox.className = `${baseClass} ${colorClass}`;
            } else {
                resultDisplayBox.className = `${baseClass} bg-slate-100 border-slate-400`;
            }
        }

        opButtons.forEach(button => {
            button.addEventListener('click', () => {
                const config = opButtonConfig[button.id];
                currentOperation = config.operation;
                updateButtonStyles(button.id);
                updateResultBoxStyle(currentOperation);
                drawAll();
            });
        });

        resetButton.addEventListener('click', () => {
            currentOperation = null;
            updateButtonStyles(null);
            updateResultBoxStyle(null);
            drawAll();
        });

        function setDisplayMode(mode) {
            displayMode = mode;
            if (mode === 'polar') {
                polarBtn.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                algebraicBtn.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
            } else {
                algebraicBtn.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                polarBtn.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
            }
            drawAll();
        }

        polarBtn.addEventListener('click', () => setDisplayMode('polar'));
        algebraicBtn.addEventListener('click', () => setDisplayMode('algebraic'));

        // --- Canvas Resizing ---
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = canvas.width / 13; 
                drawAll();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        // Initial draw
        setTimeout(() => {
            resizeCanvas();
            setDisplayMode('algebraic');
            updateButtonStyles(null); // Set initial button state
            updateResultBoxStyle(null);
        }, 50);

    </script>
</body>
</html>

