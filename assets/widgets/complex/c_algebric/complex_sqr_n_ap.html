<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שורשי מספר מרוכב - מישור גאוס</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- KaTeX for mathematical rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMckDpbDM7QIYBEf1VlBDavfi1dCQpk9AIr35VPAvRhtGDs/i" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'David Libre', serif;
            overflow: hidden;
        }
        .math-text, .katex .text {
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        .toggle-btn-active {
            background-color: #475569;
            color: white;
        }
        .toggle-btn-inactive {
            background-color: #e2e8f0;
            color: #475569;
        }
        .katex {
            font-size: 1.1em !important;
            text-align: center;
        }
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #cbd5e1;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* Blue */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* Blue */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        #rootsListContainer {
            height: 120px;
            overflow-y: auto;
            background-color: #f5f3ff; /* violet-50 */
            border: 1px solid #ddd6fe; /* violet-200 */
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 2px;
            padding: 4px;
            font-size: 0.75rem;
            line-height: 1.3;
        }
        #rootsListContainer div:hover {
            background-color: #c4b5fd; /* violet-300 */
        }
        #rootsListContainer div.highlighted-result {
            font-weight: 700;
            color: #4c1d95; /* violet-800 */
        }
        #slider-ticks span.active-tick {
            font-weight: 700;
            color: #1d4ed8; /* blue-700 */
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-2 md:p-4">

    <div class="w-full max-w-6xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        
        <div class="w-full max-w-4xl flex flex-col items-center">
             <div class="text-center mb-2 flex-shrink-0">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-600">מישור גאוס האינטראקטיבי</h1>
                <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה כדי לשנות את המספר, ובחר את סדר השורש</p>
            </div>
            <div id="canvas-container" class="w-full bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
                <canvas id="complexPlane"></canvas>
            </div>
        </div>

        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-2 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600 text-center">הוצאת שורש n-י של מספר מרוכב</h2>
             <div id="side-formula" class="w-full bg-amber-50 border border-amber-200 py-1 px-1 rounded-md text-slate-700 font-bold shadow-sm flex items-center justify-center" dir="ltr"></div>

            <div class="w-full flex justify-center my-1">
                <div class="flex border border-slate-300 rounded-lg overflow-hidden">
                    <button id="polarBtn" class="toggle-btn-inactive px-4 py-1 text-sm font-bold transition-colors">הצגה קוטבית</button>
                    <button id="algebraicBtn" class="toggle-btn-active px-4 py-1 text-sm font-bold transition-colors">הצגה אלגברית</button>
                </div>
            </div>
             <div id="valueDisplay" class="bg-green-100 border border-green-200 p-2 rounded-xl shadow-md text-lg font-bold w-full text-center math-text min-h-[40px] flex items-center justify-center"></div>
            
             <p class="text-xs font-bold text-slate-500 text-center mt-1 mb-0">השורשים (w<sub>k</sub>):</p>
             <div id="rootsListContainer" class="w-full rounded-lg text-sm math-text" dir="ltr"></div>

            <div class="w-full bg-blue-100 border border-blue-200 p-2 rounded-xl shadow-md flex items-center gap-2" dir="rtl">
                <label for="rootSlider" class="font-bold text-blue-800 text-right flex-shrink-0 w-1/3 leading-tight">בחר סדר שורש (n)</label>
                <div class="flex-grow" dir="ltr">
                    <input type="range" id="rootSlider" min="2" max="8" value="2" step="1" class="w-full">
                    <div id="slider-ticks" class="relative h-4 mt-1 w-[calc(100%-20px)] mx-auto"></div>
                </div>
            </div>
            <button id="resetBtn" class="w-full bg-amber-400 hover:bg-amber-500 text-white font-bold py-2 px-4 rounded-xl shadow-md transition-colors">איפוס</button>
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const polarBtn = document.getElementById('polarBtn');
        const algebraicBtn = document.getElementById('algebraicBtn');
        const rootSlider = document.getElementById('rootSlider');
        const resetBtn = document.getElementById('resetBtn');
        const rootsListContainer = document.getElementById('rootsListContainer');
        let displayMode = 'algebraic';

        // --- Color Configuration ---
        const pointColor = '#16a34a'; // Green for z
        const rootPointColor = '#8b5cf6'; // Violet for roots
        const realColor = '#3b82f6'; // Blue
        const imagColor = '#ef4444'; // Red
        const polarRadiusColor = '#f97316'; // Orange
        const polarAngleColor = '#6366f1'; // Indigo
        const rootCircleColor = '#ef4444'; // Red for the roots' circle
        const gridColor = '#f1f5f9';
        const axisColor = '#36454F';
        const tickColor = '#000000';
        const fontColor = '#475569';
        const highlightColor = '#facc15'; // Yellow

        // --- Point Configuration ---
        const pointRadius = 8;
        const rootPointRadius = 5;

        let origin = { x: 0, y: 0 };
        let scale = 1; 
        
        // --- State ---
        let point = { a: 1.0, b: 0.0 }; 
        const initialPoint = { a: 1.0, b: 0.0 };
        let rootN = 2;
        let isDragging = false;
        let highlightedRootIndex = -1;

        // --- Coordinate Conversion Functions ---
        function complexToCanvas(a, b) {
            return { x: origin.x + a * scale, y: origin.y - b * scale };
        }

        function canvasToComplex(x, y) {
            return { a: (x - origin.x) / scale, b: (origin.y - y) / scale };
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.lineWidth = 1;
            const unit = 1 * scale; // Major grid lines every 1 unit
            const subUnit = 0.25 * scale; // Minor grid lines every 0.25 units
            
            const xMax = canvas.width;
            const yMax = canvas.height;

            // Minor grid lines
            ctx.strokeStyle = '#f8fafc'; // lighter grid color
            for (let x = origin.x + subUnit; x < xMax; x += subUnit) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, yMax); ctx.stroke();
            }
            for (let x = origin.x - subUnit; x > 0; x -= subUnit) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, yMax); ctx.stroke();
            }
            for (let y = origin.y + subUnit; y < yMax; y += subUnit) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(xMax, y); ctx.stroke();
            }
            for (let y = origin.y - subUnit; y > 0; y -= subUnit) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(xMax, y); ctx.stroke();
            }
            
            // Major grid lines
            ctx.strokeStyle = gridColor;
            for (let x = origin.x + unit; x < xMax; x += unit) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, yMax); ctx.stroke();
            }
            for (let x = origin.x - unit; x > 0; x -= unit) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, yMax); ctx.stroke();
            }
            for (let y = origin.y + unit; y < yMax; y += unit) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(xMax, y); ctx.stroke();
            }
            for (let y = origin.y - unit; y > 0; y -= unit) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(xMax, y); ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height); ctx.stroke();
            
            drawArrowhead(ctx, canvas.width - 2, origin.y, 0, axisColor);
            drawArrowhead(ctx, origin.x, 2, -Math.PI / 2, axisColor);

            ctx.fillStyle = fontColor;
            ctx.font = 'bold 14px Tinos';
            ctx.direction = 'ltr';
            
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText('Re', canvas.width - 25, origin.y + 19);
            
            ctx.textAlign = 'right';
            ctx.fillText('Im', origin.x - 8, 16);
            
            ctx.font = '14px Tinos';
            
            const maxLabelX = Math.floor(canvasToComplex(canvas.width, origin.y).a);
            const maxLabelY = Math.floor(canvasToComplex(origin.x, 0).b);

            // Draw labels and ticks
            ctx.strokeStyle = tickColor;
            ctx.lineWidth = 1;
            const tickLength = 5;
            const smallTickLength = 3;

            // Real axis
            for (let i = 1; i <= maxLabelX + 1; i++) {
                // Positive side
                const posX = origin.x + i * scale;
                if (posX < canvas.width - 20) { 
                    ctx.beginPath();
                    ctx.moveTo(posX, origin.y - tickLength);
                    ctx.lineTo(posX, origin.y + tickLength);
                    ctx.stroke();
                }
                if (posX < canvas.width - 40) { 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'alphabetic';
                    ctx.fillText(i.toString(), posX, origin.y + 19);
                }
                const halfPosX = origin.x + (i - 0.5) * scale;
                if (halfPosX < canvas.width - 20) {
                    ctx.beginPath();
                    ctx.moveTo(halfPosX, origin.y - smallTickLength);
                    ctx.lineTo(halfPosX, origin.y + smallTickLength);
                    ctx.stroke();
                }

                // Negative side
                const negX = origin.x - i * scale;
                ctx.beginPath();
                ctx.moveTo(negX, origin.y - tickLength);
                ctx.lineTo(negX, origin.y + tickLength);
                ctx.stroke();
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText((-i).toString(), negX, origin.y + 19);
                
                const halfNegX = origin.x - (i - 0.5) * scale;
                ctx.beginPath();
                ctx.moveTo(halfNegX, origin.y - smallTickLength);
                ctx.lineTo(halfNegX, origin.y + smallTickLength);
                ctx.stroke();
            }
            
            // Imaginary axis
            for (let i = 1; i <= maxLabelY + 1; i++) {
                // Positive side
                const posY = origin.y - i * scale;
                if (posY > 20) { // Check if not too close to the top edge
                    ctx.beginPath();
                    ctx.moveTo(origin.x - tickLength, posY);
                    ctx.lineTo(origin.x + tickLength, posY);
                    ctx.stroke();
                    
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(i.toString(), origin.x - 8, posY);

                    const halfPosY = origin.y - (i - 0.5) * scale;
                    ctx.beginPath();
                    ctx.moveTo(origin.x - smallTickLength, halfPosY);
                    ctx.lineTo(origin.x + smallTickLength, halfPosY);
                    ctx.stroke();
                }

                // Negative side
                const negY = origin.y + i * scale;
                if (negY < canvas.height - 20) { // Check if not too close to the bottom edge
                    ctx.beginPath();
                    ctx.moveTo(origin.x - tickLength, negY);
                    ctx.lineTo(origin.x + tickLength, negY);
                    ctx.stroke();

                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText((-i).toString(), origin.x - 8, negY);

                    const halfNegY = origin.y + (i - 0.5) * scale;
                    ctx.beginPath();
                    ctx.moveTo(origin.x - smallTickLength, halfNegY);
                    ctx.lineTo(origin.x + smallTickLength, halfNegY);
                    ctx.stroke();
                }
            }
        }
        
        function drawPointAndProjections() {
            const canvasPos = complexToCanvas(point.a, point.b);
            
            if (displayMode === 'algebraic') {
                ctx.save();
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = realColor;
                ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(canvasPos.x, origin.y); ctx.stroke();
                ctx.strokeStyle = imagColor;
                ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(origin.x, canvasPos.y); ctx.stroke();
                ctx.restore();
            }

            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = pointColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            drawIntelligentLabel(canvasPos, 'z', null, pointColor, pointRadius);
        }

        function drawRoots() {
            const r = Math.hypot(point.a, point.b);
            const theta = Math.atan2(point.b, point.a);
            
            const root_r = Math.pow(r, 1 / rootN);
            const angle_step = 2 * Math.PI / rootN;

            let rootPoints = [];
            let rootComplexValues = [];

            for (let k = 0; k < rootN; k++) {
                const root_theta = (theta + 2 * Math.PI * k) / rootN;
                const a_k = root_r * Math.cos(root_theta);
                const b_k = root_r * Math.sin(root_theta);
                rootPoints.push(complexToCanvas(a_k, b_k));
                rootComplexValues.push({a: a_k, b: b_k});
            }

            // Draw polygon connecting the roots
            ctx.strokeStyle = rootPointColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(rootPoints[0].x, rootPoints[0].y);
            for (let i = 1; i < rootPoints.length; i++) {
                ctx.lineTo(rootPoints[i].x, rootPoints[i].y);
            }
            ctx.closePath();
            ctx.stroke();

            // Draw polar elements if in polar mode
            if (displayMode === 'polar') {
                // Draw dashed circle for roots
                ctx.save();
                ctx.strokeStyle = rootCircleColor;
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(origin.x, origin.y, root_r * scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();

                // Draw sectors and labels
                for (let k = 0; k < rootN; k++) {
                    const p = rootPoints[k];
                    const prev_theta = (theta + 2 * Math.PI * (k - 1)) / rootN;
                    const current_theta = (theta + 2 * Math.PI * k) / rootN;
                    
                    // Draw radius to the root
                    ctx.beginPath();
                    ctx.moveTo(origin.x, origin.y);
                    ctx.lineTo(p.x, p.y);
                    ctx.strokeStyle = rootPointColor;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.5;
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    // Draw angle sector arc
                    ctx.beginPath();
                    ctx.moveTo(origin.x, origin.y);
                    ctx.arc(origin.x, origin.y, root_r * scale, -prev_theta, -current_theta, true);
                    ctx.closePath();
                    ctx.fillStyle = polarAngleColor;
                    ctx.globalAlpha = 0.1;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Draw angle label outside the circle
                    ctx.save();
                    ctx.fillStyle = polarAngleColor;
                    ctx.font = 'bold 13px Tinos';
                    ctx.direction = 'ltr';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const labelAngle = -(current_theta - angle_step / 2);
                    const labelRadius = root_r * scale + 18; // Position label outside the circle
                    const textX = origin.x + labelRadius * Math.cos(labelAngle);
                    const textY = origin.y + labelRadius * Math.sin(labelAngle);
                    ctx.fillText(`${Math.round(360/rootN)}°`, textX, textY);
                    ctx.restore();

                    // Draw radius length label on each root's radius, if it's large enough to be readable
                    if (root_r > 1) {
                        ctx.save();
                        ctx.fillStyle = polarRadiusColor;
                        ctx.font = 'bold 16px Tinos';
                        ctx.direction = 'ltr';
                        
                        const labelX = p.x - (p.x - origin.x) * 0.20;
                        const labelY = p.y - (p.y - origin.y) * 0.20;
                        ctx.translate(labelX, labelY);
                        
                        let rotation = -current_theta;
                        let normalized_angle = current_theta % (2 * Math.PI);
                        if (normalized_angle < 0) {
                            normalized_angle += 2 * Math.PI;
                        }
                        if (normalized_angle > Math.PI / 2 && normalized_angle < 3 * Math.PI / 2) {
                            rotation += Math.PI;
                        }
                        ctx.rotate(rotation);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText(root_r.toFixed(1), 0, -3);
                        ctx.restore();
                    }
                }
            }

            // Draw the root points and their labels
            rootPoints.forEach((p, k) => {
                const isHighlighted = k === highlightedRootIndex;
                ctx.beginPath();
                ctx.arc(p.x, p.y, isHighlighted ? rootPointRadius + 3 : rootPointRadius, 0, 2 * Math.PI);
                ctx.fillStyle = rootPointColor;
                ctx.fill();
                ctx.strokeStyle = isHighlighted ? highlightColor : 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                drawIntelligentLabel(p, 'w', k, rootPointColor, rootPointRadius);
            });
            
            updateRootsList(rootComplexValues);
        }
        
        function drawIntelligentLabel(canvasPos, base, subIndex, color, radius) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = color;
            const angle = Math.atan2(canvasPos.y - origin.y, canvasPos.x - origin.x);
            const offset = radius + 8; // Consistent offset
            const anchorX = canvasPos.x + offset * Math.cos(angle);
            const anchorY = canvasPos.y + offset * Math.sin(angle);
            
            ctx.font = 'bold 16px Tinos';
            const baseWidth = ctx.measureText(base).width;
            let subWidth = 0;
            let subText = '';

            if (subIndex !== null) {
                ctx.font = 'bold 12px Tinos';
                subText = subIndex.toString();
                subWidth = ctx.measureText(subText).width;
            }

            const totalWidth = baseWidth + subWidth;
            let finalX = anchorX;
            let finalY = anchorY;

            // Horizontal alignment logic
            if (Math.cos(angle) < -0.1) { // Left side
                finalX -= totalWidth; 
            } else if (Math.abs(Math.cos(angle)) < 0.1) { // Top/bottom
                finalX -= totalWidth / 2; 
            }
            
            // Consistent vertical alignment
            ctx.textBaseline = 'middle';

            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Tinos';
            ctx.fillText(base, finalX, finalY);

            if (subIndex !== null) {
                ctx.font = 'bold 12px Tinos';
                // Adjust subscript position to be slightly lower and to the right
                ctx.fillText(subText, finalX + baseWidth, finalY + 6);
            }
            ctx.restore(); 
        }
        
        function drawRadiusVector() {
            if (displayMode !== 'polar') return;
            const canvasPos = complexToCanvas(point.a, point.b);
            const r_z = Math.hypot(point.a, point.b);
            const angle_z = Math.atan2(point.b, point.a);

            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = pointColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            if (r_z > 1) {
                ctx.save();
                ctx.fillStyle = pointColor;
                ctx.font = 'bold 16px Tinos';
                ctx.direction = 'ltr';
                
                const labelX = canvasPos.x - (canvasPos.x - origin.x) * 0.15;
                const labelY = canvasPos.y - (canvasPos.y - origin.y) * 0.15;
                ctx.translate(labelX, labelY);
                
                let rotation = -angle_z;
                let normalized_angle = angle_z < 0 ? angle_z + 2 * Math.PI : angle_z;
                if (normalized_angle > Math.PI / 2 && normalized_angle < 3 * Math.PI / 2) {
                    rotation += Math.PI;
                }
                ctx.rotate(rotation);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`r = ${r_z.toFixed(1)}`, 0, -5);
                ctx.restore();
            }
        }

        function drawArrowhead(ctx, x, y, angle, color) {
            const headlen = 10;
            ctx.save();
            ctx.fillStyle = color;
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-headlen, headlen / 2.5);
            ctx.lineTo(-headlen, -headlen / 2.5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function formatAlgebraic(a, b, precision = 1) {
            const a_val = parseFloat(a.toFixed(precision));
            const b_val = parseFloat(b.toFixed(precision));
            const a_is_zero = Math.abs(a_val) < 0.05;
            const b_is_zero = Math.abs(b_val) < 0.05;

            if (a_is_zero && b_is_zero) return '0';
            if (b_is_zero) return `${a_val.toFixed(precision)}`;
            if (a_is_zero) return `${b_val.toFixed(precision)}i`;
            
            const sign = b_val > 0 ? '+' : '-';
            return `${a_val.toFixed(precision)} ${sign} ${Math.abs(b_val).toFixed(precision)}i`;
        }

        function updateDisplay() {
            const r_z = Math.hypot(point.a, point.b);
            const angle_z_rad = Math.atan2(point.b, point.a);
            let angle_z_deg = angle_z_rad * 180 / Math.PI;

            let valueHTML = '';
            if (displayMode === 'algebraic') {
                const a_val = point.a;
                const b_val = point.b;
                const a_is_zero = Math.abs(a_val) < 0.05;
                const b_is_zero = Math.abs(b_val) < 0.05;

                let content = `<span style="color: ${pointColor};">z = </span>`;
                if (a_is_zero && b_is_zero) {
                    content += `<span style="color: ${realColor};">0</span>`;
                } else if (b_is_zero) {
                    content += `<span style="color: ${realColor};">${a_val.toFixed(1)}</span>`;
                } else if (a_is_zero) {
                    content += `<span style="color: ${imagColor};">${b_val.toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                } else {
                    const imagSign = b_val >= 0 ? '+' : '-';
                    content += `<span style="color: ${realColor};">${a_val.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(b_val).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                }
                valueHTML = `<span style="direction: ltr;">${content}</span>`;

            } else {
                valueHTML = `<span style="direction: ltr;"><span style="color: ${pointColor};">z = </span><span style="color:${polarRadiusColor};">${r_z.toFixed(1)}</span><span style="color: ${pointColor};"> cis(</span><span style="color:${polarAngleColor};">${Math.round(angle_z_deg)}°</span><span style="color: ${pointColor};">)</span></span>`;
            }
            
            valueDisplay.innerHTML = valueHTML;
        }
        
        function updateRootsList(complexValues) {
            rootsListContainer.innerHTML = '';
            complexValues.forEach((val, k) => {
                const item = document.createElement('div');
                item.className = 'p-1 cursor-pointer flex items-center justify-center';
                if (k === highlightedRootIndex) {
                    item.classList.add('highlighted-result');
                }
                
                const leftText = `w<sub>${k}</sub> =`;
                let rightText;

                if (displayMode === 'algebraic') {
                    rightText = formatAlgebraic(val.a, val.b, 1);
                } else {
                    const r = Math.hypot(val.a, val.b);
                    let angle = Math.atan2(val.b, val.a) * 180 / Math.PI;
                    if (angle < -179.9) angle = 180; // Tidy up display for -180
                    rightText = `${r.toFixed(1)} cis(${Math.round(angle)}°)`;
                }
                
                item.innerHTML = `
                    <span class="w-[40%] text-right pr-1">${leftText}</span>
                    <span class="w-[60%] text-left pl-1">${rightText}</span>
                `;

                item.addEventListener('mouseover', () => {
                    highlightedRootIndex = k;
                    drawAll();
                });
                item.addEventListener('mouseout', () => {
                    highlightedRootIndex = -1;
                    drawAll();
                });
                rootsListContainer.appendChild(item);
            });
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            if (displayMode === 'polar') {
                drawRadiusVector();
            }
            drawRoots();
            drawPointAndProjections();
            updateDisplay();
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 15) * (pointRadius + 15)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                point.a = complexPos.a;
                point.b = complexPos.b;
                drawAll();
            }
        }

        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        function handleReset() {
            point.a = initialPoint.a;
            point.b = initialPoint.b;
            rootSlider.value = 2;
            rootN = 2;
            updateSliderTicks(2);
            drawAll();
        }
        
        function updateSliderTicks(currentValue) {
            const ticks = document.querySelectorAll('#slider-ticks span');
            ticks.forEach(tick => {
                if (parseInt(tick.textContent) === currentValue) {
                    tick.classList.add('active-tick');
                } else {
                    tick.classList.remove('active-tick');
                }
            });
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        rootSlider.addEventListener('input', (e) => {
            rootN = parseInt(e.target.value);
            updateSliderTicks(rootN);
            drawAll();
        });

        resetBtn.addEventListener('click', handleReset);
        
        function setDisplayMode(mode) {
            displayMode = mode;
            polarBtn.classList.toggle('toggle-btn-active', mode === 'polar');
            polarBtn.classList.toggle('toggle-btn-inactive', mode !== 'polar');
            algebraicBtn.classList.toggle('toggle-btn-active', mode === 'algebraic');
            algebraicBtn.classList.toggle('toggle-btn-inactive', mode !== 'algebraic');
            drawAll();
        }

        polarBtn.addEventListener('click', () => setDisplayMode('polar'));
        algebraicBtn.addEventListener('click', () => setDisplayMode('algebraic'));

        function setupSliderTicks() {
             const sliderTicks = document.getElementById('slider-ticks');
             if (!sliderTicks) return;
             sliderTicks.innerHTML = ''; // Clear previous ticks
             const min = parseInt(rootSlider.min);
             const max = parseInt(rootSlider.max);
             for (let i = min; i <= max; i++) {
                 const tick = document.createElement('span');
                 tick.textContent = i;
                 const percent = ((i - min) / (max - min)) * 100;
                 tick.className = 'absolute text-xs text-slate-500';
                 tick.style.left = `${percent}%`;
                 tick.style.transform = 'translateX(-50%)';
                 sliderTicks.appendChild(tick);
             }
             updateSliderTicks(parseInt(rootSlider.value));
        }

        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            if (!parent) return;
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;
            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = Math.min(canvas.width, canvas.height) / 7.0; 
                setupSliderTicks();
                drawAll();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        function initialize() {
            const katexCheck = setInterval(() => {
                if (typeof katex !== 'undefined') {
                    clearInterval(katexCheck);
                    
                    const sideFormulaContainer = document.getElementById('side-formula');
                    if (sideFormulaContainer) {
                        try {
                            const formula = String.raw`w_k = \sqrt[n]{r} \cdot \text{cis}\left(\frac{\theta + 360^\circ k}{n}\right)`;
                            katex.render(formula, sideFormulaContainer, { throwOnError: false, displayMode: true });
                        } catch (e) {
                            console.error('KaTeX rendering failed:', e);
                            sideFormulaContainer.textContent = 'w_k = n√r * cis((θ+360k)/n)';
                        }
                    }
                    resizeCanvas();
                }
            }, 50);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }

    </script>
</body>
</html>

