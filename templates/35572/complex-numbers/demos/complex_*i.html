<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'David Libre', serif;
            overflow: hidden; 
        }
        .math-text {
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        .interactive-box {
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
        }
        .interactive-box:hover {
            transform: scale(1.05);
        }
        .action-btn {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl text-center mb-2 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800">מישור גאוס האינטראקטיבי</h1>
        <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה או לחץ על הפעולות</p>
    </div>

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        <!-- Canvas Container -->
        <div id="canvas-container" class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
            <canvas id="complexPlane"></canvas>
        </div>

        <!-- Display Container -->
        <div class="w-full max-w-xs flex flex-col justify-center space-y-4 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600 text-center">משמעות גיאומטרית של כפל ב- i</h2>
             <div id="valueDisplay" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-2xl font-bold w-full text-center math-text">
                <!-- Content for z will be generated by JS -->
            </div>
             <!-- Container for the two side-by-side boxes -->
             <div class="flex gap-2 w-full">
                <div id="multiplyByI" class="interactive-box flex-1 text-center bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-2xl text-blue-800 font-bold">
                    <span class="math-text" dir="ltr">z &times; i</span>
                </div>
                <div id="multiplyByNegI" class="interactive-box flex-1 text-center bg-red-100 border border-red-200 p-3 rounded-xl shadow-md text-2xl text-red-800 font-bold">
                    <span class="math-text" dir="ltr">z &times; (-i)</span>
                </div>
            </div>
             <!-- Reset Button -->
            <button id="resetBtn" class="action-btn w-full bg-yellow-400 hover:bg-yellow-500 text-white font-bold py-2 px-4 rounded-xl shadow-md">איפוס</button>
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const multiplyByI = document.getElementById('multiplyByI');
        const multiplyByNegI = document.getElementById('multiplyByNegI');
        const resetBtn = document.getElementById('resetBtn');

        // --- Configuration ---
        const pointRadius = 10;
        const pointColor = '#16a34a'; // Green-600
        const resultPointColor = '#3b82f6'; // Blue-500
        const negResultPointColor = '#8b5cf6'; // Violet-500
        const realColor = '#3b82f6';
        const imagColor = '#ef4444'; 
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // --- State ---
        let point = { a: 1, b: 0 }; 
        let history = { pos: [], neg: [] };
        let isDragging = false;
        let isAnimating = false;

        // --- Utility Functions ---
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Coordinate Conversion ---
        function complexToCanvas(a, b) { return { x: origin.x + a * scale, y: origin.y - b * scale }; }
        function canvasToComplex(x, y) { return { a: (x - origin.x) / scale, b: (origin.y - y) / scale }; }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let x = origin.x - scale; x > 0; x -= scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = origin.y + scale; y < canvas.height; y += scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = origin.y - scale; y > 0; y -= scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2);  ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            ctx.fillStyle = fontColor; ctx.font = '14px "David Libre"'; ctx.textAlign = 'left';
            ctx.fillText('(ציר מדומה)', origin.x + 8, 12);
            ctx.textAlign = 'right'; ctx.fillText('(ציר ממשי)', canvas.width - 15, origin.y - 8);
            ctx.font = 'bold 16px Tinos'; ctx.fillStyle = labelFontColor;
            ctx.fillText('x', canvas.width - 15, origin.y + 15); ctx.fillStyle = fontColor;
            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center';
                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) { ctx.fillText(i.toString(), xPos, origin.y + 15); }
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { ctx.textBaseline = 'middle'; ctx.fillText(i.toString(), origin.x - 12, yPos); }
                }
                ctx.restore();
            }
            ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center'; ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale; ctx.fillText('-6', xPosMinus6, origin.y + 15);
            ctx.textBaseline = 'middle'; let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 12, yPosMinus5); ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = labelFontColor; let yPos5 = origin.y - 5 * scale;
            ctx.fillText('iy', origin.x - 12, yPos5); ctx.restore();
        }

        function drawDynamicCircle() {
            const radius = Math.sqrt(point.a * point.a + point.b * point.b) * scale;
            if (radius < 1) return; 
            ctx.save(); ctx.beginPath(); ctx.strokeStyle = '#34d399';
            ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
            ctx.arc(origin.x, origin.y, radius, 0, 2 * Math.PI); ctx.stroke(); ctx.restore();
        }
        
        function drawComplexPoint(p, color, index, alpha = 1.0) {
            if (!p) return;
            const rgbaColor = hexToRgba(color, alpha);
            const canvasPos = complexToCanvas(p.a, p.b);
            const epsilon = 0.01;
            const isOverlapping = Math.abs(p.a - point.a) < epsilon && Math.abs(p.b - point.b) < epsilon && index !== 0;

            // Vector
            ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = rgbaColor; ctx.lineWidth = 2.5; ctx.stroke();
            
            // Point
            ctx.beginPath(); ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = hexToRgba('#FFFFFF', alpha); ctx.lineWidth = 3; 
            
            if (isOverlapping) {
                // Draw as a ring if overlapping
                ctx.strokeStyle = rgbaColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                // Draw as a filled circle
                ctx.fillStyle = rgbaColor;
                ctx.fill();
                ctx.stroke();
            }
            
            drawSubscriptLabel(canvasPos, color, index, alpha, isOverlapping);
        }

        function drawRightAngleMarker(start, end, color, alpha) {
            if (!start || !end) return;
            const size = 20; 
            const len1 = Math.sqrt(start.a ** 2 + start.b ** 2);
            if (len1 === 0) return;

            const u1 = { a: start.a / len1, b: start.b / len1 };
            const u2 = { a: end.a / len1, b: end.b / len1 };
            
            const p1_marker = { a: u1.a * size / scale, b: u1.b * size / scale };
            const p2_marker = { a: u2.a * size / scale, b: u2.b * size / scale };
            const p3_marker = { a: p1_marker.a + p2_marker.a, b: p1_marker.b + p2_marker.b };

            const c_p1 = complexToCanvas(p1_marker.a, p1_marker.b);
            const c_p2 = complexToCanvas(p2_marker.a, p2_marker.b);
            const c_p3 = complexToCanvas(p3_marker.a, p3_marker.b);

            ctx.save();
            ctx.strokeStyle = hexToRgba(axisColor, alpha);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(c_p1.x, c_p1.y);
            ctx.lineTo(c_p3.x, c_p3.y);
            ctx.lineTo(c_p2.x, c_p2.y);
            ctx.stroke();
            ctx.restore();
        }
        
        function drawSubscriptLabel(canvasPos, color, index, alpha, isOverlapping = false) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = hexToRgba(color, alpha); 
            ctx.textBaseline = 'bottom';

            ctx.font = 'bold 18px Tinos';
            const baseText = 'z';
            const baseWidth = ctx.measureText(baseText).width;

            ctx.font = 'bold 14px Tinos';
            const subText = index.toString();
            const subWidth = ctx.measureText(subText).width;

            const totalWidth = baseWidth + subWidth;
            const margin = 15;
            
            let xOffset = canvasPos.x + margin;
            // If overlapping, move label to the other side
            if (isOverlapping || (xOffset + totalWidth > canvas.width - margin)) {
                xOffset = canvasPos.x - margin - totalWidth;
            }

            ctx.font = 'bold 18px Tinos';
            ctx.fillText(baseText, xOffset, canvasPos.y);
            ctx.font = 'bold 14px Tinos';
            ctx.fillText(subText, xOffset + baseWidth, canvasPos.y + 4);

            ctx.restore();
        }
        
        function updateDisplay() {
            let valueHTML, statusText, statusColor; const epsilon = 0.05;
            if (Math.abs(point.b) < epsilon) { 
                statusText = 'מספר ממשי טהור'; statusColor = realColor;
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
            } else if (Math.abs(point.a) < epsilon) {
                statusText = 'מספר מדומה טהור'; statusColor = imagColor;
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${imagColor};">${point.b.toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
            } else { 
                statusText = 'מספר מרוכב'; statusColor = pointColor;
                const imagSign = point.b >= 0 ? '+' : '-';
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
            }
            valueDisplay.innerHTML = `${valueHTML}<br><span class="text-sm font-normal" style="color: ${statusColor}; font-family: 'David Libre', serif;">(${statusText})</span>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawDynamicCircle(); 
            drawComplexPoint(point, pointColor, 0);

            history.pos.forEach((item, i) => {
                const isLast = i === history.pos.length - 1;
                const alpha = isLast ? 1.0 : Math.max(0.1, 1.0 - (history.pos.length - 1 - i) * 0.25);
                drawRightAngleMarker(item.start, item.point, resultPointColor, alpha);
                drawComplexPoint(item.point, resultPointColor, i + 1, alpha);
            });
            history.neg.forEach((item, i) => {
                const isLast = i === history.neg.length - 1;
                const alpha = isLast ? 1.0 : Math.max(0.1, 1.0 - (history.neg.length - 1 - i) * 0.25);
                drawRightAngleMarker(item.start, item.point, negResultPointColor, alpha);
                drawComplexPoint(item.point, negResultPointColor, -(i + 1), alpha);
            });
            updateDisplay();
        }

        // --- Animation ---
        function animateRotation(start, end, angle, color, index, historyArray) {
            isAnimating = true;
            let startTime = null;
            const radius = Math.sqrt(start.a ** 2 + start.b ** 2);
            const startAngle = Math.atan2(start.b, start.a);
            const endAngle = startAngle + angle;

            function animationStep(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / 500, 1);
                const currentAngle = startAngle + (endAngle - startAngle) * progress;
                const animatingPoint = { a: radius * Math.cos(currentAngle), b: radius * Math.sin(currentAngle) };

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(); drawAxes(); drawDynamicCircle(); 
                drawComplexPoint(point, pointColor, 0);
                history.pos.forEach((item, i) => {
                    const alpha = Math.max(0.1, 1.0 - (history.pos.length - i) * 0.25);
                    drawRightAngleMarker(item.start, item.point, resultPointColor, alpha);
                    drawComplexPoint(item.point, resultPointColor, i + 1, alpha);
                });
                 history.neg.forEach((item, i) => {
                    const alpha = Math.max(0.1, 1.0 - (history.neg.length - i) * 0.25);
                    drawRightAngleMarker(item.start, item.point, negResultPointColor, alpha);
                    drawComplexPoint(item.point, negResultPointColor, -(i + 1), alpha);
                });
                
                drawComplexPoint(animatingPoint, color, index);
                
                if (progress < 1) {
                    requestAnimationFrame(animationStep);
                } else {
                    isAnimating = false;
                    historyArray.push({start: start, point: end});
                    drawAll(); 
                }
            }
            requestAnimationFrame(animationStep);
        }

        function updateHistoryFromBase(basePoint) {
            let lastPos = basePoint;
            history.pos.forEach(item => {
                item.start = { ...lastPos };
                item.point = { a: -lastPos.b, b: lastPos.a };
                lastPos = item.point;
            });
            
            let lastNeg = basePoint;
            history.neg.forEach(item => {
                item.start = { ...lastNeg };
                item.point = { a: lastNeg.b, b: -lastNeg.a };
                lastNeg = item.point;
            });
        }


        // --- Event Handlers ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            if (isAnimating) return;
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x; const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 10) * (pointRadius + 10)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                point = canvasToComplex(pos.x, pos.y);
                updateHistoryFromBase(point); 
                drawAll();
            }
        }

        function handleEnd() { isDragging = false; canvas.style.cursor = 'grab'; }

        multiplyByI.addEventListener('click', () => {
            if(isAnimating) return;
            const startPoint = history.pos.length > 0 ? history.pos[history.pos.length - 1].point : point;
            const endPoint = { a: -startPoint.b, b: startPoint.a };
            const nextIndex = history.pos.length + 1;
            animateRotation(startPoint, endPoint, Math.PI / 2, resultPointColor, nextIndex, history.pos);
        });
        
        multiplyByNegI.addEventListener('click', () => {
            if(isAnimating) return;
            const startPoint = history.neg.length > 0 ? history.neg[history.neg.length - 1].point : point;
            const endPoint = { a: startPoint.b, b: -startPoint.a };
            const nextIndex = -(history.neg.length + 1);
            animateRotation(startPoint, endPoint, -Math.PI / 2, negResultPointColor, nextIndex, history.neg);
        });

        resetBtn.addEventListener('click', () => {
            if (isAnimating) return;
            point = { a: 1, b: 0 };
            history = { pos: [], neg: [] };
            drawAll();
        });

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth; const parentHeight = parent.clientHeight;
            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth; canvas.height = parentHeight;
                origin.x = canvas.width / 2; origin.y = canvas.height / 2;
                scale = canvas.width / 13; 
                drawAll();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 50);
    </script>
</body>
</html>

