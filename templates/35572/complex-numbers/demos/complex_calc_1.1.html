<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>פעולות חשבון במישור גאוס</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Assistant', sans-serif;
            overflow: hidden; /* Prevent body scrolling */
        }
        canvas {
            cursor: grab;
            display: block; 
            touch-action: none; /* Important for touch devices */
        }
        canvas:active {
            cursor: grabbing;
        }
        .operation-btn {
            transition: all 0.2s;
        }
        .operation-btn.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl text-center mb-2 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800">פעולות חשבון במישור גאוס</h1>
        <p class="text-slate-600 text-sm md:text-base">גרור את הנקודות z<sub>1</sub> ו-z<sub>2</sub> ובחר בפעולה הרצויה</p>
    </div>

    <div class="w-full max-w-6xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        <!-- Canvas Container -->
        <div id="canvas-container" class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
            <canvas id="complexPlane"></canvas>
        </div>

        <!-- Display & Controls Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-3 mt-2 md:mt-0">
            <div id="z1_display" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-xl text-blue-800 w-full text-center min-h-[58px]"></div>
            <div id="z2_display" class="bg-red-100 border border-red-200 p-3 rounded-xl shadow-md text-xl text-red-800 w-full text-center min-h-[58px]"></div>
            
            <div class="grid grid-cols-4 justify-center items-center gap-3 my-2 w-full">
                <button id="add-btn" class="operation-btn active bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full">+</button>
                <button id="subtract-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full">-</button>
                <button id="multiply-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full">×</button>
                <button id="sqrt-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full">√</button>
            </div>

            <div id="result_display" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-xl text-green-800 w-full text-center min-h-[58px]"></div>
        
            <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg w-full mt-2">איפוס</button>
        </div>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const z1Display = document.getElementById('z1_display');
        const z2Display = document.getElementById('z2_display');
        const resultDisplay = document.getElementById('result_display');
        
        // Buttons
        const addBtn = document.getElementById('add-btn');
        const subtractBtn = document.getElementById('subtract-btn');
        const multiplyBtn = document.getElementById('multiply-btn');
        const sqrtBtn = document.getElementById('sqrt-btn');
        const resetBtn = document.getElementById('reset-btn');

        // --- Configuration ---
        const pointRadius = 9; // Unified radius for all points
        const colors = {
            z1: '#3b82f6', // blue-500
            z2: '#ef4444', // red-500
            result: '#16a34a', // green-600
        }
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // --- State ---
        let point1 = { a: 1, b: 0 }; 
        let point2 = { a: 0, b: 1 };
        let resultPoint = { a: 0, b: 0};
        let draggingPoint = null; // null, 'point1', or 'point2'
        let currentOperation = 'add';


        // --- Coordinate Conversion ---
        function complexToCanvas(a, b) { return { x: origin.x + a * scale, y: origin.y - b * scale }; }
        function canvasToComplex(x, y) { return { a: (x - origin.x) / scale, b: (origin.y - y) / scale }; }

        // --- Calculation ---
        function calculateResult() {
            switch (currentOperation) {
                case 'add':
                    resultPoint.a = point1.a + point2.a;
                    resultPoint.b = point1.b + point2.b;
                    break;
                case 'subtract':
                    resultPoint.a = point1.a - point2.a;
                    resultPoint.b = point1.b - point2.b;
                    break;
                case 'multiply':
                    resultPoint.a = (point1.a * point2.a) - (point1.b * point2.b);
                    resultPoint.b = (point1.a * point2.b) + (point1.b * point2.a);
                    break;
                case 'sqrt':
                    const r = Math.hypot(point1.a, point1.b);
                    const phi = Math.atan2(point1.b, point1.a);
                    resultPoint.a = Math.sqrt(r) * Math.cos(phi / 2);
                    resultPoint.b = Math.sqrt(r) * Math.sin(phi / 2);
                    break;
            }
            drawAll();
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let x = origin.x - scale; x > 0; x -= scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = origin.y + scale; y < canvas.height; y += scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            for (let y = origin.y - scale; y > 0; y -= scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            // X-Axis (Real) with arrowhead
            ctx.beginPath(); 
            ctx.moveTo(0, origin.y); 
            ctx.lineTo(canvas.width, origin.y); 
            ctx.stroke();
            ctx.beginPath(); 
            ctx.moveTo(canvas.width - 12, origin.y - 7); 
            ctx.lineTo(canvas.width, origin.y); 
            ctx.lineTo(canvas.width - 12, origin.y + 7); 
            ctx.stroke();

            // Y-Axis (Imaginary) with arrowhead
            ctx.beginPath(); 
            ctx.moveTo(origin.x, canvas.height); 
            ctx.lineTo(origin.x, 0); 
            ctx.stroke();
            ctx.beginPath(); 
            ctx.moveTo(origin.x - 7, 12); 
            ctx.lineTo(origin.x, 2); 
            ctx.lineTo(origin.x + 7, 12); 
            ctx.stroke();
            
            // Draw numbers
            ctx.fillStyle = fontColor;
            const yNumberOffset = 10; 
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                ctx.save();
                ctx.direction = 'ltr';
                ctx.textAlign = 'center';
                ctx.font = '12px Assistant';
                let xPos = origin.x + i * scale;
                if (Math.abs(xPos - origin.x) < canvas.width/2 - 20) {
                    ctx.fillText(i, xPos, origin.y + 15);
                }
                let yPos = origin.y - i * scale;
                if (Math.abs(yPos - origin.y) < canvas.height/2 - 20) {
                    ctx.fillText(i, origin.x - yNumberOffset, yPos);
                }
                ctx.restore();
            }

            // Draw Axis Labels
            ctx.fillStyle = labelFontColor;
            ctx.font = 'bold 16px Assistant';
            
            const yLabelOffset = 8;
            ctx.textAlign = 'right';
            ctx.fillText('Im(z)', origin.x - yLabelOffset, 15);

            ctx.textAlign = 'center';
            ctx.fillText('Re(z)', canvas.width - 35, origin.y + 15);
        }
        
        function drawPoint(p, color, name) {
            const canvasPos = complexToCanvas(p.a, p.b);
            
            // Radius Vector
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.stroke();
            ctx.restore();

            // Point
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
           
            // Label Logic
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = labelFontColor;
            ctx.font = 'bold 16px Assistant';
            
            const offset = 12; // Set total distance to 12px
            const diagonalOffset = offset / Math.sqrt(2);
            
            let xSign = 1;
            let ySign = -1; // -1 is up

            // Reflect if too close to edges
            if (canvasPos.x > canvas.width - 40) xSign = -1;
            if (canvasPos.y < 20) ySign = 1;

            const labelX = canvasPos.x + xSign * diagonalOffset;
            const labelY = canvasPos.y + ySign * diagonalOffset;

            ctx.textAlign = xSign > 0 ? 'left' : 'right';
            ctx.textBaseline = ySign > 0 ? 'top' : 'bottom';
            
            ctx.fillText(name, labelX, labelY);
            ctx.restore();
        }

        // --- Update & Main Draw ---
        function formatComplex(p, name) {
            const epsilon = 1e-9;
            const a = p.a;
            const b = p.b;

            if (Math.abs(a) < epsilon && Math.abs(b) < epsilon) return '0';
            
            let realPart = '';
            if (Math.abs(a) > epsilon) {
                realPart = a.toFixed(1);
            }

            let imagPart = '';
            if (Math.abs(b) > epsilon) {
                if (Math.abs(b - 1) < epsilon) imagPart = 'i';
                else if (Math.abs(b + 1) < epsilon) imagPart = '-i';
                else imagPart = `${b.toFixed(1)}i`;
            }

            if (realPart && imagPart) {
                if (b > 0) return `${realPart} + ${imagPart.replace('-', '')}`;
                return `${realPart} - ${imagPart.replace('-', '')}`;
            }
            return realPart || imagPart;
        }


        function updateDisplay() {
            z1Display.innerHTML = `<span style="direction: ltr; display: inline-block;"><b style="color:${colors.z1};">z₁</b> = ${formatComplex(point1, 'z1')}</span>`;
            z2Display.innerHTML = `<span style="direction: ltr; display: inline-block;"><b style="color:${colors.z2};">z₂</b> = ${formatComplex(point2, 'z2')}</span>`;

            let resultStr = '';
            if (currentOperation === 'sqrt') {
                resultStr = `<b style="color:${colors.result};">z</b> = √z₁ = ${formatComplex(resultPoint, 'z')}`;
            } else {
                const opSymbol = {add: '+', subtract: '-', multiply: '×'}[currentOperation];
                resultStr = `<b style="color:${colors.result};">z</b> = z₁ ${opSymbol} z₂ = ${formatComplex(resultPoint, 'z')}`;
            }
            resultDisplay.innerHTML = `<span style="direction: ltr; display: inline-block;">${resultStr}</span>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawPoint(point1, colors.z1, 'z₁');
            if (currentOperation !== 'sqrt') {
                 drawPoint(point2, colors.z2, 'z₂');
            }
            drawPoint(resultPoint, colors.result, 'z');
            updateDisplay();
        }

        // --- Event Handlers ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const p1Pos = complexToCanvas(point1.a, point1.b);
            const p2Pos = complexToCanvas(point2.a, point2.b);

            const d1 = Math.hypot(pos.x - p1Pos.x, pos.y - p1Pos.y);
            const d2 = Math.hypot(pos.x - p2Pos.x, pos.y - p2Pos.y);

            if (d1 < pointRadius + 5) {
                draggingPoint = point1;
            } else if (d2 < pointRadius + 5 && currentOperation !== 'sqrt') {
                draggingPoint = point2;
            } else {
                draggingPoint = null;
            }
            if(draggingPoint) canvas.style.cursor = 'grabbing';
        }

        function handleMove(e) {
            if (draggingPoint) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                draggingPoint.a = complexPos.a;
                draggingPoint.b = complexPos.b;
                calculateResult();
            }
        }

        function handleEnd() {
            draggingPoint = null;
            canvas.style.cursor = 'grab';
        }
        
        function setActiveButton(btn) {
            [addBtn, subtractBtn, multiplyBtn, sqrtBtn].forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        addBtn.addEventListener('click', () => {
            currentOperation = 'add';
            setActiveButton(addBtn);
            calculateResult();
        });
        subtractBtn.addEventListener('click', () => {
            currentOperation = 'subtract';
            setActiveButton(subtractBtn);
            calculateResult();
        });
        multiplyBtn.addEventListener('click', () => {
            currentOperation = 'multiply';
            setActiveButton(multiplyBtn);
            calculateResult();
        });
        sqrtBtn.addEventListener('click', () => {
            currentOperation = 'sqrt';
            setActiveButton(sqrtBtn);
            calculateResult();
        });
        resetBtn.addEventListener('click', () => {
            point1 = { a: 1, b: 0 };
            point2 = { a: 0, b: 1 };
            calculateResult();
        });


        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = canvas.width / 15; 
                calculateResult();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        // Initial load
        setTimeout(() => {
            resizeCanvas();
            setActiveButton(addBtn); // Set initial active button
        }, 50);

    </script>
</body>
</html>

