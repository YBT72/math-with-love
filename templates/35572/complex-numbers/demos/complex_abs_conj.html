<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Updated Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            /* Updated font for Hebrew text */
            font-family: 'David Libre', serif;
            overflow: auto; /* Allow scrolling for more content */
        }
        .math-text {
            /* Updated font for Mathematical text */
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl text-center mb-2 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800">מישור גאוס האינטראקטיבי</h1>
        <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה כדי לשנות את המספר המרוכב</p>
    </div>

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        <!-- Rectangular Background Container -->
        <div id="canvas-container" class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
            <canvas id="complexPlane"></canvas>
        </div>

        <!-- Display Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-2 mt-2 md:mt-0">
             <h2 class="text-center font-bold text-slate-600 leading-tight mb-2">
                <span class="text-xl">ערך מוחלט וצמוד למספר מרוכב:</span><br>
                <span class="text-lg">משמעות גיאומטרית</span>
             </h2>

            <!-- NEW: Parallel columns container -->
            <div class="flex flex-row-reverse gap-2 w-full">
                <!-- Column for z -->
                <div class="flex flex-col gap-2 w-1/2">
                    <div id="valueDisplay" class="bg-green-100 border border-green-200 p-2 rounded-xl shadow-md text-lg font-bold w-full text-center math-text flex items-center justify-center" style="height: 60px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="realPartDisplay" class="bg-blue-100 border border-blue-200 p-2 rounded-xl shadow-md text-base text-blue-800 w-full text-center math-text flex items-center justify-center" style="height: 50px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="imagPartDisplay" class="bg-red-100 border border-red-200 p-2 rounded-xl shadow-md text-base text-red-800 w-full text-center math-text flex items-center justify-center" style="height: 50px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="modulusDisplay" class="bg-yellow-100 border border-yellow-200 p-2 rounded-xl shadow-md text-base text-yellow-800 w-full text-center math-text flex items-center justify-center" style="height: 50px;">
                        <!-- Content generated by JS -->
                    </div>
                </div>

                <!-- Column for z-bar -->
                <div class="flex flex-col gap-2 w-1/2">
                    <div id="conjugateValueDisplay" class="bg-purple-100 border border-purple-200 p-2 rounded-xl shadow-md text-lg font-bold w-full text-center math-text flex items-center justify-center" style="height: 60px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="conjugateRealPartDisplay" class="bg-blue-100 border border-blue-200 p-2 rounded-xl shadow-md text-base text-blue-800 w-full text-center math-text flex items-center justify-center" style="height: 50px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="conjugateImagPartDisplay" class="bg-red-100 border border-red-200 p-2 rounded-xl shadow-md text-base text-red-800 w-full text-center math-text flex items-center justify-center" style="height: 50px;">
                        <!-- Content generated by JS -->
                    </div>
                     <div id="conjugateModulusDisplay" class="bg-yellow-100 border border-yellow-200 p-2 rounded-xl shadow-md text-base text-yellow-800 w-full text-center math-text flex items-center justify-center" style="height: 50px;">
                        <!-- Content generated by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const realPartDisplay = document.getElementById('realPartDisplay');
        const imagPartDisplay = document.getElementById('imagPartDisplay');
        const modulusDisplay = document.getElementById('modulusDisplay');
        const conjugateValueDisplay = document.getElementById('conjugateValueDisplay');
        const conjugateRealPartDisplay = document.getElementById('conjugateRealPartDisplay');
        const conjugateImagPartDisplay = document.getElementById('conjugateImagPartDisplay');
        const conjugateModulusDisplay = document.getElementById('conjugateModulusDisplay');


        // --- Configuration ---
        const pointRadius = 10;
        const pointColor = '#16a34a'; // Green-600
        const realColor = '#3b82f6'; // Blue-500
        const imagColor = '#ef4444'; // Red-500
        const conjugateColor = '#8b5cf6'; // Violet-500
        const modulusColor = '#ca8a04'; // Amber-600
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // Draggable point state
        let point = { a: 1, b: 2 }; 
        let isDragging = false;

        // --- Coordinate Conversion Functions ---
        function complexToCanvas(a, b) {
            return {
                x: origin.x + a * scale,
                y: origin.y - b * scale
            };
        }

        function canvasToComplex(x, y) {
            return {
                a: (x - origin.x) / scale,
                b: (origin.y - y) / scale
            };
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            for (let x = origin.x + scale; x < canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let x = origin.x - scale; x > 0; x -= scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = origin.y + scale; y < canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            for (let y = origin.y - scale; y > 0; y -= scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(canvas.width, origin.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 12, origin.y - 7);
            ctx.lineTo(canvas.width - 2, origin.y);
            ctx.lineTo(canvas.width - 12, origin.y + 7);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(origin.x, canvas.height);
            ctx.lineTo(origin.x, 2); 
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(origin.x - 7, 12);
            ctx.lineTo(origin.x, 2);
            ctx.lineTo(origin.x + 7, 12);
            ctx.stroke();
            
            ctx.fillStyle = fontColor;
            
            ctx.font = '14px "David Libre"';
            ctx.textAlign = 'left';
            ctx.fillText('(ציר מדומה)', origin.x + 8, 12);

            const labelXPos = canvas.width - 15;
            ctx.textAlign = 'right';
            ctx.fillText('(ציר ממשי)', labelXPos, origin.y - 8); 

            ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = labelFontColor; 
            ctx.fillText('x', labelXPos, origin.y + 15);
            ctx.fillStyle = fontColor; 

            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save();
                ctx.direction = 'ltr';
                ctx.textAlign = 'center';

                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) {
                   ctx.fillText(i, xPos, origin.y + 15);
                }
                
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { 
                       ctx.textBaseline = 'middle';
                       ctx.fillText(i.toString(), origin.x - 12, yPos);
                    }
                }
                ctx.restore();
            }
            ctx.save();
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';
            ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale;
            ctx.fillText('-6', xPosMinus6, origin.y + 15);
            
            ctx.textBaseline = 'middle';
            let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 12, yPosMinus5);
            
            ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = labelFontColor;
            let yPos5 = origin.y - 5 * scale;
            ctx.fillText('iy', origin.x - 12, yPos5);

            ctx.restore();
        }

        function drawRadiusVectorsAndLabels() {
            const radius = Math.sqrt(point.a * point.a + point.b * point.b);
            const canvasPos = complexToCanvas(point.a, point.b);
            const conjugateCanvasPos = complexToCanvas(point.a, -point.b);
            
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = pointColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(conjugateCanvasPos.x, conjugateCanvasPos.y);
            ctx.strokeStyle = conjugateColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();

            drawRadiusLabel(point.a, point.b, radius, '|z|', pointColor);
            drawRadiusLabel(point.a, -point.b, radius, '|z\u0304|', conjugateColor);
        }

        function drawRadiusLabel(a, b, radius, label, color) {
            if (radius * scale < 30) return;

            ctx.save();
            
            const midX = origin.x + (a * scale) / 2;
            const midY = origin.y - (b * scale) / 2;
            ctx.translate(midX, midY);

            let angle = Math.atan2(-b, a);

            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                angle += Math.PI;
            }
            
            ctx.rotate(angle);

            ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            ctx.direction = 'ltr';
            const textToDraw = `${label} = ${radius.toFixed(1)}`;
            
            const textWidth = ctx.measureText(textToDraw).width;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillRect(-textWidth/2 - 4, -18, textWidth + 8, 20);

            ctx.fillStyle = color;
            ctx.fillText(textToDraw, 0, 0);
            
            ctx.restore();
        }

        function drawPointAndProjections() {
            const canvasPos = complexToCanvas(point.a, point.b);

            ctx.save();
            ctx.setLineDash([4, 4]); 
            
            ctx.strokeStyle = realColor;
            ctx.lineWidth = 1; 
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(canvasPos.x, origin.y);
            ctx.stroke();

            ctx.strokeStyle = imagColor;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(origin.x, canvasPos.y);
            ctx.stroke();
            ctx.restore(); 
            
            const highlightRadius = 5;

            ctx.fillStyle = realColor;
            const realPos = complexToCanvas(point.a, 0);
            ctx.beginPath();
            ctx.arc(realPos.x, realPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = imagColor;
            const imagPos = complexToCanvas(0, point.b);
            ctx.beginPath();
            ctx.arc(imagPos.x, imagPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = pointColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            drawIntelligentZLabel(canvasPos);
        }

        function drawConjugatePoint() {
            const conjugateB = -point.b;
            const canvasPos = complexToCanvas(point.a, conjugateB);

            ctx.save();
            ctx.setLineDash([4, 4]);

            ctx.strokeStyle = realColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(canvasPos.x, origin.y);
            ctx.stroke();

            ctx.strokeStyle = imagColor;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(origin.x, canvasPos.y);
            ctx.stroke();
            ctx.restore();

            const highlightRadius = 5;

            ctx.fillStyle = imagColor;
            const imagPos = complexToCanvas(0, conjugateB);
            ctx.beginPath();
            ctx.arc(imagPos.x, imagPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = conjugateColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            drawIntelligentConjugateLabel(canvasPos);
        }

        function drawIntelligentConjugateLabel(canvasPos) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.font = 'bold 16px Tinos';

            const textHeight = 16;
            const topMargin = 5;
            const rightMargin = 15;

            const zText = 'z\u0304 = ';
            const realText = point.a.toFixed(1);
            const imagText = Math.abs(point.b).toFixed(1);
            const signText = point.b >= 0 ? ' - ' : ' + ';
            const iText = 'i';
            const fullText = zText + realText + signText + imagText + iText;
            const textWidth = ctx.measureText(fullText).width;
            const margin = 5;

            let textBaseline = 'top';
            let yOffset = canvasPos.y + pointRadius + margin;
            if (yOffset + textHeight > canvas.height - 5) {
                textBaseline = 'bottom';
                yOffset = canvasPos.y - (pointRadius / 2);
            }

            let xOffset = canvasPos.x + pointRadius + margin;
            if (xOffset + textWidth > canvas.width - rightMargin) {
                xOffset = canvasPos.x - pointRadius - margin - textWidth;
            }
            
            ctx.textBaseline = textBaseline;
            ctx.textAlign = 'left';

            const parts = [
                { text: zText, color: conjugateColor },
                { text: realText, color: realColor },
                { text: signText, color: conjugateColor },
                { text: imagText, color: imagColor },
                { text: iText, color: conjugateColor }
            ];
            
            let currentX = xOffset;
            parts.forEach(part => {
                ctx.fillStyle = part.color;
                ctx.fillText(part.text, currentX, yOffset);
                currentX += ctx.measureText(part.text).width;
            });
            
            ctx.restore();
        }

        function drawIntelligentZLabel(canvasPos) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.font = 'bold 16px Tinos';

            const textHeight = 16;
            const topMargin = 5;
            const rightMargin = 15;

            const zText = 'z = ';
            const realText = point.a.toFixed(1);
            const imagText = Math.abs(point.b).toFixed(1);
            const signText = point.b >= 0 ? ' + ' : ' - ';
            const iText = 'i';
            const fullText = zText + realText + signText + imagText + iText;
            const textWidth = ctx.measureText(fullText).width;
            const margin = 5;

            let textBaseline = 'bottom';
            let yOffset = canvasPos.y - (pointRadius / 2);
            if (yOffset - textHeight < topMargin) {
                textBaseline = 'top';
                yOffset = canvasPos.y + pointRadius + margin;
            }

            let xOffset = canvasPos.x + pointRadius + margin;
            if (xOffset + textWidth > canvas.width - rightMargin) {
                xOffset = canvasPos.x - pointRadius - margin - textWidth;
            }

            ctx.textBaseline = textBaseline;
            ctx.textAlign = 'left';

            const parts = [
                { text: zText, color: pointColor },
                { text: realText, color: realColor },
                { text: signText, color: pointColor },
                { text: imagText, color: imagColor },
                { text: iText, color: pointColor }
            ];
            
            let currentX = xOffset;
            parts.forEach(part => {
                ctx.fillStyle = part.color;
                ctx.fillText(part.text, currentX, yOffset);
                currentX += ctx.measureText(part.text).width;
            });
            
            ctx.restore(); 
        }
        
        function updateDisplay() {
            let valueHTML, conjugateValueHTML;
            const epsilon = 0.05;

            if (Math.abs(point.b) < epsilon) {
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
                conjugateValueHTML = `<span style="color: ${conjugateColor};">z\u0304 = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
            } else if (Math.abs(point.a) < epsilon) {
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${imagColor};">${point.b.toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                conjugateValueHTML = `<span style="color: ${conjugateColor};">z\u0304 = </span><span style="color: ${imagColor};">${(-point.b).toFixed(1)}</span><span style="color: ${conjugateColor};">i</span>`;
            } else {
                const imagSign = point.b >= 0 ? '+' : '-';
                const conjugateImagSign = point.b >= 0 ? '-' : '+';
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
                conjugateValueHTML = `<span style="color: ${conjugateColor};">z\u0304 = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${conjugateColor};">${conjugateImagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${conjugateColor};">i</span>`;

            }

            valueDisplay.innerHTML = `<span style="direction: ltr;">${valueHTML}</span>`;
            realPartDisplay.innerHTML = `<b style="direction: ltr;">Re(z) = <b style="color:${realColor};">${point.a.toFixed(1)}</b></b>`;
            imagPartDisplay.innerHTML = `<b style="direction: ltr;">Im(z) = <b style="color:${imagColor};">${point.b.toFixed(1)}</b></b>`;
            const radius = Math.sqrt(point.a * point.a + point.b * point.b);
            modulusDisplay.innerHTML = `<b style="direction: ltr;">|z| = <b style="color:${modulusColor};">${radius.toFixed(1)}</b></b>`;
            
            conjugateValueDisplay.innerHTML = `<span style="direction: ltr;">${conjugateValueHTML}</span>`;
            conjugateRealPartDisplay.innerHTML = `<b style="direction: ltr;">Re(z\u0304) = <b style="color:${realColor};">${point.a.toFixed(1)}</b></b>`;
            conjugateImagPartDisplay.innerHTML = `<b style="direction: ltr;">Im(z\u0304) = <b style="color:${imagColor};">${(-point.b).toFixed(1)}</b></b>`;
            conjugateModulusDisplay.innerHTML = `<b style="direction: ltr;">|z\u0304| = <b style="color:${modulusColor};">${radius.toFixed(1)}</b></b>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawRadiusVectorsAndLabels(); 
            drawPointAndProjections();
            drawConjugatePoint(); 
            updateDisplay();
        }

        // --- Event Handlers ---

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 5) * (pointRadius + 5)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                point.a = complexPos.a;
                point.b = complexPos.b;
                drawAll();
            }
        }

        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        // --- Canvas Resizing ---
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = canvas.width / 13; 
                drawAll();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        setTimeout(resizeCanvas, 50);

    </script>
</body>
</html>

