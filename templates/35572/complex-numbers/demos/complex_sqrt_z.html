<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMckDpbOc7ymOFAKfCcfdudfA1BErQoRvkDn4CIvQEfRIbMzp" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>

    <!-- Updated Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            /* Updated font for Hebrew text */
            font-family: 'David Libre', serif;
            overflow: hidden; /* Prevent body scrolling */
        }
        .math-text {
            /* Updated font for Mathematical text */
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        /* KaTeX font size adjustment */
        .katex {
            font-size: 1.1em !important;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl text-center mb-2 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800">מישור גאוס האינטראקטיבי</h1>
        <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה (w) כדי למצוא את שורשיה</p>
    </div>

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        <!-- Rectangular Background Container -->
        <div id="canvas-container" class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
            <canvas id="complexPlane"></canvas>
        </div>

        <!-- Display Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-4 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600 text-center">
‎                פתרון משוואה ריבועית פשוטה<br>בשדה של מספרים מרוכבים
             </h2>
             <div id="valueDisplay" dir="ltr" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-xl font-bold text-green-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <div id="solution1Display" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-xl text-blue-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <div id="solution2Display" class="bg-purple-100 border border-purple-200 p-3 rounded-xl shadow-md text-xl text-purple-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const solution1Display = document.getElementById('solution1Display');
        const solution2Display = document.getElementById('solution2Display');

        // --- Configuration ---
        const pointRadius = 10;
        const mainPointColor = '#16a34a'; // Green-600
        const solution1Color = '#3b82f6'; // Blue-500
        const solution2Color = '#8b5cf6'; // Violet-500
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // Draggable point state
        let pointW = { a: -3, b: 4 }; // Represents w = z^2
        let isDragging = false;

        // --- Helper Functions ---
        function formatNumber(p) {
            const epsilon = 0.01;
            const a = p.a;
            const b = p.b;

            if (Math.abs(a) < epsilon && Math.abs(b) < epsilon) {
                return '0';
            }
            if (Math.abs(a) < epsilon) {
                return `${b.toFixed(1)}i`;
            }
            if (Math.abs(b) < epsilon) {
                return `${a.toFixed(1)}`;
            }
            const sign = b >= 0 ? '+' : '-';
            return `${a.toFixed(1)} ${sign} ${Math.abs(b).toFixed(1)}i`;
        };

        // --- Math Functions ---
        function calculateSquareRoots(w) {
            const r = Math.sqrt(w.a * w.a + w.b * w.b);
            const theta = Math.atan2(w.b, w.a);

            const root_r = Math.sqrt(r);
            const half_theta = theta / 2;

            const z1 = {
                a: root_r * Math.cos(half_theta),
                b: root_r * Math.sin(half_theta)
            };

            const z2 = {
                a: -z1.a,
                b: -z1.b
            };
            return { z1, z2 };
        }

        // --- Coordinate Conversion Functions ---
        function complexToCanvas(a, b) {
            return {
                x: origin.x + a * scale,
                y: origin.y - b * scale
            };
        }

        function canvasToComplex(x, y) {
            return {
                a: (x - origin.x) / scale,
                b: (origin.y - y) / scale
            };
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let x = origin.x - scale; x > 0; x -= scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = origin.y + scale; y < canvas.height; y += scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = origin.y - scale; y > 0; y -= scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            ctx.fillStyle = fontColor; ctx.font = '14px "David Libre"';
            ctx.textAlign = 'left'; ctx.fillText('(ציר מדומה)', origin.x + 8, 12);
            ctx.textAlign = 'right'; ctx.fillText('(ציר ממשי)', canvas.width - 15, origin.y - 8); 
            ctx.font = 'bold 16px Tinos'; ctx.fillStyle = labelFontColor; 
            ctx.fillText('x', canvas.width - 15, origin.y + 15); ctx.fillStyle = fontColor; 
            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center';
                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) { ctx.fillText(i.toString(), xPos, origin.y + 15); }
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { ctx.textBaseline = 'middle'; ctx.fillText(i.toString(), origin.x - 12, yPos); }
                }
                ctx.restore();
            }
            ctx.save(); ctx.direction = 'ltr'; ctx.textAlign = 'center'; ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale; ctx.fillText('-6', xPosMinus6, origin.y + 15);
            ctx.textBaseline = 'middle'; let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 12, yPosMinus5);
            ctx.font = 'bold 16px Tinos'; ctx.fillStyle = labelFontColor;
            let yPos5 = origin.y - 5 * scale; ctx.fillText('iy', origin.x - 12, yPos5);
            ctx.restore();
        }
        
        function drawPoint(p, radius, color, label) {
            const canvasPos = complexToCanvas(p.a, p.b);
            // Draw vector
            ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(canvasPos.x, canvasPos.y);
            ctx.strokeStyle = color; ctx.lineWidth = 2.5; ctx.stroke();
            // Draw point
            ctx.beginPath(); ctx.arc(canvasPos.x, canvasPos.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
            // Pass the point 'p' to the label drawing function
            drawIntelligentZLabel(canvasPos, p, color, label);
        }

        function drawIntelligentZLabel(canvasPos, p, color, label) {
            const offset = 7.5; // The x and y distance for the 45-degree offset

            // Initial position: 45 degrees top-right
            let x = canvasPos.x + offset;
            let y = canvasPos.y - offset;

            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Tinos';

            // Default alignment for top-right
            let textAlign = 'left';
            let textBaseline = 'bottom';

            const textWidth = ctx.measureText(label).width;
            const textHeight = 16; // Approximation of font height in pixels

            // Check right edge collision
            if (x + textWidth > canvas.width - 10) { // 10px padding from edge
                x = canvasPos.x - offset;
                textAlign = 'right';
            }

            // Check top edge collision
            if (y - textHeight < 10) { // 10px padding from edge
                y = canvasPos.y + offset;
                textBaseline = 'top';
            }

            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            
            ctx.fillText(label, x, y);
            ctx.restore(); 
        }
        
        function updateDisplay(w, z1, z2) {
            // Use KaTeX to render the formula
            const latexString = "z^2 = w \\implies z_{1,2} = \\pm\\sqrt{w}";
            try {
                // Check if katex is loaded
                if (typeof katex !== 'undefined') {
                    katex.render(latexString, valueDisplay, {
                        throwOnError: false,
                        displayMode: true
                    });
                } else {
                     // Fallback to simple HTML if KaTeX is not loaded
                    valueDisplay.innerHTML = `<span dir="ltr"><b>z² = w => z₁,₂ = ±√w</b></span>`;
                }
            } catch (e) {
                console.error("KaTeX rendering failed:", e);
                // Fallback to simple HTML if KaTeX fails
                valueDisplay.innerHTML = `<span dir="ltr"><b>z² = w => z₁,₂ = ±√w</b></span>`;
            }

            solution1Display.innerHTML = `<span dir="ltr"><b>z₁</b> = ${formatNumber(z1)}</span>`;
            solution2Display.innerHTML = `<span dir="ltr"><b>z₂</b> = ${formatNumber(z2)}</span>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            
            const { z1, z2 } = calculateSquareRoots(pointW);
            
            // Draw w = z^2
            drawPoint(pointW, pointRadius, mainPointColor, `w = ${formatNumber(pointW)}`);
            
            // Draw solutions
            drawPoint(z1, pointRadius, solution1Color, 'z₁');
            drawPoint(z2, pointRadius, solution2Color, 'z₂');
            
            updateDisplay(pointW, z1, z2);
        }

        // --- Event Handlers ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(pointW.a, pointW.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 5) * (pointRadius + 5)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                pointW = canvasToComplex(pos.x, pos.y);
                drawAll();
            }
        }

        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                // Restored scale calculation
                scale = canvas.width / 13;
                drawAll();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        setTimeout(resizeCanvas, 50);

    </script>
</body>
</html>

