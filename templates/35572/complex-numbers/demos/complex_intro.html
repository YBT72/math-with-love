<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מישור גאוס אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Updated Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;700&family=Tinos:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            /* Updated font for Hebrew text */
            font-family: 'David Libre', serif;
            overflow: hidden; /* Prevent body scrolling */
        }
        .math-text {
            /* Updated font for Mathematical text */
            font-family: 'Tinos', 'Times New Roman', serif;
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl text-center mb-2 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800">מישור גאוס האינטראקטיבי</h1>
        <p class="text-slate-600 text-sm md:text-base">גרור את הנקודה הירוקה כדי לשנות את המספר המרוכב</p>
    </div>

    <div class="w-full max-w-5xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        <!-- Rectangular Background Container -->
        <div id="canvas-container" class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
            <canvas id="complexPlane"></canvas>
        </div>

        <!-- Display Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-4 mt-2 md:mt-0">
             <h2 class="text-lg font-bold text-slate-600">מבוא למספרים מרוכבים</h2>
             <div id="valueDisplay" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-2xl font-bold w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <div id="realPartDisplay" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-base text-blue-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
             <div id="imagPartDisplay" class="bg-red-100 border border-red-200 p-3 rounded-xl shadow-md text-base text-red-800 w-full text-center math-text">
                <!-- Content generated by JS -->
            </div>
        </div>
    </div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('valueDisplay');
        const realPartDisplay = document.getElementById('realPartDisplay');
        const imagPartDisplay = document.getElementById('imagPartDisplay');

        // --- Configuration ---
        const pointRadius = 10;
        const pointColor = '#16a34a'; // Green-600
        const realColor = '#3b82f6'; // Blue-500
        const imagColor = '#ef4444'; // Red-500
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // Draggable point state
        let point = { a: 1, b: 2 }; 
        let isDragging = false;

        // --- Coordinate Conversion Functions ---
        function complexToCanvas(a, b) {
            return {
                x: origin.x + a * scale,
                y: origin.y - b * scale
            };
        }

        function canvasToComplex(x, y) {
            return {
                a: (x - origin.x) / scale,
                b: (origin.y - y) / scale
            };
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            for (let x = origin.x + scale; x < canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let x = origin.x - scale; x > 0; x -= scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = origin.y + scale; y < canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            for (let y = origin.y - scale; y > 0; y -= scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(canvas.width, origin.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 12, origin.y - 7);
            ctx.lineTo(canvas.width - 2, origin.y);
            ctx.lineTo(canvas.width - 12, origin.y + 7);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(origin.x, canvas.height);
            ctx.lineTo(origin.x, 2); 
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(origin.x - 7, 12);
            ctx.lineTo(origin.x, 2);
            ctx.lineTo(origin.x + 7, 12);
            ctx.stroke();
            
            ctx.fillStyle = fontColor;
            
            // Hebrew text with David Libre
            ctx.font = '14px "David Libre"';
            ctx.textAlign = 'left';
            ctx.fillText('(ציר מדומה)', origin.x + 8, 12);

            // X-axis label
            const labelXPos = canvas.width - 15;
            ctx.textAlign = 'right';
            ctx.fillText('(ציר ממשי)', labelXPos, origin.y - 8); 

            // Math text with Times New Roman (Tinos)
            ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = labelFontColor; 
            ctx.fillText('x', labelXPos, origin.y + 15);
            ctx.fillStyle = fontColor; 

            ctx.font = '14px Tinos';
            for (let i = -6; i <= 6; i++) {
                if (i === 0 || i === 6) continue;
                ctx.save();
                ctx.direction = 'ltr';
                ctx.textAlign = 'center';

                let xPos = origin.x + i * scale;
                if (xPos > 20 && xPos < canvas.width - 20) {
                   ctx.fillText(i, xPos, origin.y + 15);
                }
                
                if (i !== 5 && i !== -5) { 
                    let yPos = origin.y - i * scale;
                    if (yPos > 20 && yPos < canvas.height - 20) { 
                       ctx.textBaseline = 'middle';
                       ctx.fillText(i.toString(), origin.x - 12, yPos);
                    }
                }
                ctx.restore();
            }
            ctx.save();
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';
            ctx.font = '14px Tinos';
            let xPosMinus6 = origin.x - 6 * scale;
            ctx.fillText('-6', xPosMinus6, origin.y + 15);
            
            ctx.textBaseline = 'middle';
            let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 12, yPosMinus5);
            
            ctx.font = 'bold 16px Tinos';
            ctx.fillStyle = labelFontColor;
            let yPos5 = origin.y - 5 * scale;
            ctx.fillText('iy', origin.x - 12, yPos5);

            ctx.restore();
        }
        
        // This function is now cleaner and calls the new helper function
        function drawPointAndProjections() {
            const canvasPos = complexToCanvas(point.a, point.b);

            ctx.save();
            ctx.setLineDash([4, 4]); 
            
            ctx.strokeStyle = realColor;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(canvasPos.x, origin.y);
            ctx.stroke();

            ctx.strokeStyle = imagColor;
            ctx.beginPath();
            ctx.moveTo(canvasPos.x, canvasPos.y);
            ctx.lineTo(origin.x, canvasPos.y);
            ctx.stroke();
            ctx.restore(); 
            
            const highlightRadius = 5;

            ctx.fillStyle = realColor;
            const realPos = complexToCanvas(point.a, 0);
            ctx.beginPath();
            ctx.arc(realPos.x, realPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = imagColor;
            const imagPos = complexToCanvas(0, point.b);
            ctx.beginPath();
            ctx.arc(imagPos.x, imagPos.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = pointColor;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            // The only modification is calling the intelligent label function
            drawIntelligentZLabel(canvasPos);
        }

        // NEW: Function to draw the z-label with reflection logic
        function drawIntelligentZLabel(canvasPos) {
            ctx.save();
            ctx.direction = 'ltr';
            ctx.font = 'bold 16px Tinos';

            const textHeight = 16;
            const topMargin = 5;
            const rightMargin = 15;

            const zText = 'z = ';
            const realText = point.a.toFixed(1);
            const imagText = Math.abs(point.b).toFixed(1);
            const signText = point.b >= 0 ? ' + ' : ' - ';
            const iText = 'i';
            const fullText = zText + realText + signText + imagText + iText;
            const textWidth = ctx.measureText(fullText).width;
            const margin = 5;

            // Vertical positioning logic
            let textBaseline = 'bottom';
            let yOffset = canvasPos.y - (pointRadius / 2); // Default above
            if (yOffset - textHeight < topMargin) {
                textBaseline = 'top'; // Switch to below
                yOffset = canvasPos.y + pointRadius + margin;
            }

            // Horizontal positioning logic
            let xOffset = canvasPos.x + pointRadius + margin;
            if (xOffset + textWidth > canvas.width - rightMargin) {
                // CORRECTED LOGIC: Calculate the start position for a right-aligned block
                xOffset = canvasPos.x - pointRadius - margin - textWidth;
            }

            ctx.textBaseline = textBaseline;
            ctx.textAlign = 'left'; // Always draw left-to-right

            // Draw the text part-by-part for coloring
            const parts = [
                { text: zText, color: pointColor },
                { text: realText, color: realColor },
                { text: signText, color: pointColor },
                { text: imagText, color: imagColor },
                { text: iText, color: pointColor }
            ];
            
            let currentX = xOffset;
            parts.forEach(part => {
                ctx.fillStyle = part.color;
                ctx.fillText(part.text, currentX, yOffset);
                currentX += ctx.measureText(part.text).width;
            });
            
            ctx.restore(); 
        }
        
        function updateDisplay() {
            let valueHTML, statusText, statusColor;
            const epsilon = 0.05; 

            if (Math.abs(point.b) < epsilon) { 
                statusText = 'מספר ממשי טהור';
                statusColor = realColor;
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span>`;
            } else if (Math.abs(point.a) < epsilon) {
                statusText = 'מספר מדומה טהור';
                statusColor = imagColor;
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${imagColor};">${point.b.toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
            } else { 
                statusText = 'מספר מרוכב';
                statusColor = pointColor;
                const imagSign = point.b >= 0 ? '+' : '-';
                valueHTML = `<span style="color: ${pointColor};">z = </span><span style="color: ${realColor};">${point.a.toFixed(1)}</span> <span style="color: ${pointColor};">${imagSign}</span> <span style="color: ${imagColor};">${Math.abs(point.b).toFixed(1)}</span><span style="color: ${pointColor};">i</span>`;
            }

            valueDisplay.innerHTML = `${valueHTML}<br><span class="text-sm font-normal" style="color: ${statusColor}; font-family: 'David Libre', serif;">(${statusText})</span>`;
            realPartDisplay.innerHTML = `<b>Re</b>(z) = <b style="color:#3b82f6;">${point.a.toFixed(1)}</b><br><span class="text-sm font-normal" style="font-family: 'David Libre', serif;">(החלק הממשי - היטל על הציר הממשי)</span>`;
            imagPartDisplay.innerHTML = `<b>Im</b>(z) = <b style="color:#ef4444;">${point.b.toFixed(1)}</b><br><span class="text-sm font-normal" style="font-family: 'David Libre', serif;">(החלק המדומה - היטל על הציר המדומה)</span>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawPointAndProjections();
            updateDisplay();
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const canvasPos = complexToCanvas(point.a, point.b);
            const dx = pos.x - canvasPos.x;
            const dy = pos.y - canvasPos.y;
            if (dx * dx + dy * dy < (pointRadius + 5) * (pointRadius + 5)) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            if (isDragging) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                point.a = complexPos.a;
                point.b = complexPos.b;
                drawAll();
            }
        }

        function handleEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                // Corrected: Make canvas fill the rectangular container
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                // Adjust scale to fit the new wider view
                scale = canvas.width / 13; 
                drawAll();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        setTimeout(resizeCanvas, 50);

    </script>
</body>
</html>
