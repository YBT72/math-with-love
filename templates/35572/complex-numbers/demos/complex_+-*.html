<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>פעולות חשבון במישור גאוס</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Assistant', sans-serif;
            overflow: hidden; /* Prevent body scrolling */
        }
        canvas {
            cursor: grab;
            display: block; 
        }
        canvas:active {
            cursor: grabbing;
        }
        .operation-btn.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-slate-100 w-full h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-5xl text-center mb-2 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800">פעולות חשבון במישור גאוס</h1>
        <p class="text-slate-600 text-sm md:text-base">גרור את הנקודות z<sub>1</sub> ו-z<sub>2</sub> ובחר בפעולה הרצויה</p>
    </div>

    <div class="w-full max-w-6xl flex flex-col md:flex-row-reverse items-center justify-center gap-4 md:gap-8 flex-grow min-h-0">
        <!-- Canvas Container -->
        <div id="canvas-container" class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-2 flex items-center justify-center" style="aspect-ratio: 1.25 / 1;">
            <canvas id="complexPlane"></canvas>
        </div>

        <!-- Display & Controls Container -->
        <div class="w-full max-w-xs flex flex-col items-center justify-center gap-3 mt-2 md:mt-0">
            <div id="z1_display" class="bg-blue-100 border border-blue-200 p-3 rounded-xl shadow-md text-xl text-blue-800 w-full text-center"></div>
            <div id="z2_display" class="bg-red-100 border border-red-200 p-3 rounded-xl shadow-md text-xl text-red-800 w-full text-center"></div>
            
            <div class="flex justify-center items-center gap-3 my-2">
                <button id="add-btn" class="operation-btn active bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full transition-all">+</button>
                <button id="subtract-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full transition-all">-</button>
                <button id="multiply-btn" class="operation-btn bg-slate-200 text-slate-800 font-bold text-2xl w-14 h-14 rounded-full transition-all">×</button>
            </div>

            <div id="result_display" class="bg-green-100 border border-green-200 p-3 rounded-xl shadow-md text-xl text-green-800 w-full text-center"></div>
        </div>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const z1Display = document.getElementById('z1_display');
        const z2Display = document.getElementById('z2_display');
        const resultDisplay = document.getElementById('result_display');
        
        // Buttons
        const addBtn = document.getElementById('add-btn');
        const subtractBtn = document.getElementById('subtract-btn');
        const multiplyBtn = document.getElementById('multiply-btn');


        // --- Configuration ---
        const pointRadius = 10;
        const resultPointRadius = 8;
        const colors = {
            z1: '#3b82f6', // blue-500
            z2: '#ef4444', // red-500
            result: '#16a34a', // green-600
        }
        
        const gridColor = '#e2e8f0'; 
        const axisColor = '#64748b'; 
        const fontColor = '#475569'; 
        const labelFontColor = '#1e293b'; 

        let origin = { x: 0, y: 0 };
        let scale = 40; 
        
        // --- State ---
        let point1 = { a: 2, b: 3 }; 
        let point2 = { a: -1, b: 1 };
        let resultPoint = { a: 0, b: 0};
        let draggingPoint = null; // null, 'point1', or 'point2'
        let currentOperation = 'add';


        // --- Coordinate Conversion ---
        function complexToCanvas(a, b) { return { x: origin.x + a * scale, y: origin.y - b * scale }; }
        function canvasToComplex(x, y) { return { a: (x - origin.x) / scale, b: (origin.y - y) / scale }; }

        // --- Calculation ---
        function calculateResult() {
            switch (currentOperation) {
                case 'add':
                    resultPoint.a = point1.a + point2.a;
                    resultPoint.b = point1.b + point2.b;
                    break;
                case 'subtract':
                    resultPoint.a = point1.a - point2.a;
                    resultPoint.b = point1.b - point2.b;
                    break;
                case 'multiply':
                    resultPoint.a = (point1.a * point2.a) - (point1.b * point2.b);
                    resultPoint.b = (point1.a * point2.b) + (point1.b * point2.a);
                    break;
            }
            drawAll();
        }

        // --- Drawing Functions ---
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            for (let x = origin.x + scale; x < canvas.width; x += scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let x = origin.x - scale; x > 0; x -= scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = origin.y + scale; y < canvas.height; y += scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            for (let y = origin.y - scale; y > 0; y -= scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvas.width - 12, origin.y - 7); ctx.lineTo(canvas.width - 2, origin.y); ctx.lineTo(canvas.width - 12, origin.y + 7); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, canvas.height); ctx.lineTo(origin.x, 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x - 7, 12); ctx.lineTo(origin.x, 2); ctx.lineTo(origin.x + 7, 12); ctx.stroke();
            
            ctx.fillStyle = fontColor;
            
            // Symmetrical Y-axis labels
            const yLabelY = 15;
            const yLabelXOffset = 15;
            
            ctx.font = '14px Assistant';
            ctx.textAlign = 'left';
            ctx.fillText('(ציר מדומה)', origin.x + yLabelXOffset, yLabelY);
            
            ctx.font = 'bold 16px Assistant';
            ctx.fillStyle = labelFontColor;
            ctx.textAlign = 'right';
            ctx.fillText('iy', origin.x - yLabelXOffset, yLabelY);

            // X-axis label
            const labelXPos = canvas.width - 15;
            ctx.textAlign = 'right';
            ctx.font = '14px Assistant'; 
            ctx.fillStyle = fontColor;
            ctx.fillText('(ציר ממשי)', labelXPos, origin.y - 8); 
            ctx.font = 'bold 16px Assistant'; 
            ctx.fillStyle = labelFontColor; 
            ctx.fillText('x', labelXPos, origin.y + 15);
            ctx.fillStyle = fontColor; 

            for (let i = -6; i <= 6; i++) {
                if (i === 0) continue;
                ctx.save();
                ctx.direction = 'ltr';
                ctx.textAlign = 'center';
                ctx.font = '14px Assistant';
                let xPos = origin.x + i * scale;
                if (i !== 6) ctx.fillText(i, xPos, origin.y + 15);
                let yPos = origin.y - i * scale;
                 if (i >= -5 && i < 5) ctx.fillText(i, origin.x - 15, yPos);
                ctx.restore();
            }
             // Explicitly draw -5 on y-axis
            ctx.save();
            ctx.direction = 'ltr';
            ctx.textAlign = 'center';
            ctx.font = '14px Assistant';
            let yPosMinus5 = origin.y - (-5 * scale);
            ctx.fillText('-5', origin.x - 15, yPosMinus5);
            ctx.restore();
        }
        
        function drawPoint(p, color, name) {
            const canvasPos = complexToCanvas(p.a, p.b);
            const radius = (name === 'z') ? resultPointRadius : pointRadius;

            // Projections
            ctx.save();
            ctx.strokeStyle = color;
            ctx.setLineDash([3, 3]); 
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(canvasPos.x, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvasPos.x, canvasPos.y); ctx.lineTo(origin.x, canvasPos.y); ctx.stroke();
            ctx.restore();

            // Point
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            if(radius === pointRadius) {
                 ctx.strokeStyle = 'white';
                 ctx.lineWidth = 2;
                 ctx.stroke();
            }
           
            // Label
            ctx.save();
            ctx.direction = 'ltr';
            ctx.fillStyle = labelFontColor;
            ctx.font = 'bold 16px Assistant';
            ctx.textBaseline = 'middle';
            ctx.textAlign = p.a >= 0 ? 'left' : 'right';
            const labelX = canvasPos.x + (p.a >= 0 ? 1 : -1) * (radius + 5);
            ctx.fillText(name, labelX, canvasPos.y);
            ctx.restore();
        }

        // --- Update & Main Draw ---
        function updateDisplay() {
            const opSymbol = {add: '+', subtract: '-', multiply: '×'}[currentOperation];
            
            z1Display.innerHTML = `<span style="direction: ltr; display: inline-block;"><b style="color:${colors.z1};">z₁</b> = ${point1.a.toFixed(1)} ${point1.b >= 0 ? '+':'-'} ${Math.abs(point1.b).toFixed(1)}i</span>`;
            z2Display.innerHTML = `<span style="direction: ltr; display: inline-block;"><b style="color:${colors.z2};">z₂</b> = ${point2.a.toFixed(1)} ${point2.b >= 0 ? '+':'-'} ${Math.abs(point2.b).toFixed(1)}i</span>`;
            resultDisplay.innerHTML = `<span style="direction: ltr; display: inline-block;"><b style="color:${colors.result};">z</b> = z₁ ${opSymbol} z₂ = ${resultPoint.a.toFixed(1)} ${resultPoint.b >= 0 ? '+':'-'} ${Math.abs(resultPoint.b).toFixed(1)}i</span>`;
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawPoint(point1, colors.z1, 'z₁');
            drawPoint(point2, colors.z2, 'z₂');
            drawPoint(resultPoint, colors.result, 'z');
            updateDisplay();
        }

        // --- Event Handlers ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                 return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPos(e);
            const p1Pos = complexToCanvas(point1.a, point1.b);
            const p2Pos = complexToCanvas(point2.a, point2.b);

            const d1 = Math.sqrt((pos.x - p1Pos.x)**2 + (pos.y - p1Pos.y)**2);
            const d2 = Math.sqrt((pos.x - p2Pos.x)**2 + (pos.y - p2Pos.y)**2);

            if (d1 < pointRadius + 5) {
                draggingPoint = point1;
            } else if (d2 < pointRadius + 5) {
                draggingPoint = point2;
            } else {
                draggingPoint = null;
            }
            if(draggingPoint) canvas.style.cursor = 'grabbing';
        }

        function handleMove(e) {
            if (draggingPoint) {
                e.preventDefault();
                const pos = getPos(e);
                const complexPos = canvasToComplex(pos.x, pos.y);
                draggingPoint.a = complexPos.a;
                draggingPoint.b = complexPos.b;
                calculateResult();
            }
        }

        function handleEnd() {
            draggingPoint = null;
            canvas.style.cursor = 'grab';
        }
        
        function setActiveButton(btn) {
            [addBtn, subtractBtn, multiplyBtn].forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        addBtn.addEventListener('click', () => {
            currentOperation = 'add';
            setActiveButton(addBtn);
            calculateResult();
        });
        subtractBtn.addEventListener('click', () => {
            currentOperation = 'subtract';
            setActiveButton(subtractBtn);
            calculateResult();
        });
        multiplyBtn.addEventListener('click', () => {
            currentOperation = 'multiply';
            setActiveButton(multiplyBtn);
            calculateResult();
        });


        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); 

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        function resizeCanvas() {
            const parent = document.getElementById('canvas-container');
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;

            if (parentWidth > 0 && parentHeight > 0) {
                canvas.width = parentWidth;
                canvas.height = parentHeight;
                origin.x = canvas.width / 2;
                origin.y = canvas.height / 2;
                scale = canvas.width / 13; 
                calculateResult(); // Recalculate and draw on resize
            }
        }

        window.addEventListener('resize', resizeCanvas);
        
        setTimeout(resizeCanvas, 50);

    </script>
</body>
</html>

